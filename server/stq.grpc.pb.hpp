// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: stq.proto
#ifndef GRPC_stq_2eproto__INCLUDED
#define GRPC_stq_2eproto__INCLUDED

#include "stq.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

class SimpleTaskQueue final {
 public:
  static constexpr char const* service_full_name() {
    return "SimpleTaskQueue";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // for login
    virtual ::grpc::Status Login(::grpc::ClientContext* context, const ::LoginReq& request, ::ExitRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>> AsyncLogin(::grpc::ClientContext* context, const ::LoginReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>>(AsyncLoginRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>> PrepareAsyncLogin(::grpc::ClientContext* context, const ::LoginReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>>(PrepareAsyncLoginRaw(context, request, cq));
    }
    virtual ::grpc::Status Logout(::grpc::ClientContext* context, const ::Inquiry& request, ::ExitRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>> AsyncLogout(::grpc::ClientContext* context, const ::Inquiry& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>>(AsyncLogoutRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>> PrepareAsyncLogout(::grpc::ClientContext* context, const ::Inquiry& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>>(PrepareAsyncLogoutRaw(context, request, cq));
    }
    // for queue
    virtual ::grpc::Status CreateQueue(::grpc::ClientContext* context, const ::QueueReq& request, ::ExitRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>> AsyncCreateQueue(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>>(AsyncCreateQueueRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>> PrepareAsyncCreateQueue(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>>(PrepareAsyncCreateQueueRaw(context, request, cq));
    }
    virtual ::grpc::Status DeleteQueue(::grpc::ClientContext* context, const ::QueueReq& request, ::ExitRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>> AsyncDeleteQueue(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>>(AsyncDeleteQueueRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>> PrepareAsyncDeleteQueue(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>>(PrepareAsyncDeleteQueueRaw(context, request, cq));
    }
    virtual ::grpc::Status ListQueue(::grpc::ClientContext* context, const ::Inquiry& request, ::ListQueueRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ListQueueRes>> AsyncListQueue(::grpc::ClientContext* context, const ::Inquiry& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ListQueueRes>>(AsyncListQueueRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ListQueueRes>> PrepareAsyncListQueue(::grpc::ClientContext* context, const ::Inquiry& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ListQueueRes>>(PrepareAsyncListQueueRaw(context, request, cq));
    }
    // for task
    // panding list
    virtual ::grpc::Status AddTask(::grpc::ClientContext* context, const ::AddTaskReq& request, ::ExitRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>> AsyncAddTask(::grpc::ClientContext* context, const ::AddTaskReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>>(AsyncAddTaskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>> PrepareAsyncAddTask(::grpc::ClientContext* context, const ::AddTaskReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>>(PrepareAsyncAddTaskRaw(context, request, cq));
    }
    virtual ::grpc::Status DeleteTask(::grpc::ClientContext* context, const ::TaskIDReq& request, ::ExitRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>> AsyncDeleteTask(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>>(AsyncDeleteTaskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>> PrepareAsyncDeleteTask(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>>(PrepareAsyncDeleteTaskRaw(context, request, cq));
    }
    virtual ::grpc::Status ListTask(::grpc::ClientContext* context, const ::QueueReq& request, ::ListTaskRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ListTaskRes>> AsyncListTask(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ListTaskRes>>(AsyncListTaskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ListTaskRes>> PrepareAsyncListTask(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ListTaskRes>>(PrepareAsyncListTaskRaw(context, request, cq));
    }
    virtual ::grpc::Status TaskState(::grpc::ClientContext* context, const ::TaskIDReq& request, ::TaskStateRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TaskStateRes>> AsyncTaskState(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TaskStateRes>>(AsyncTaskStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TaskStateRes>> PrepareAsyncTaskState(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TaskStateRes>>(PrepareAsyncTaskStateRaw(context, request, cq));
    }
    // for current
    virtual ::grpc::Status CurrentRunning(::grpc::ClientContext* context, const ::QueueReq& request, ::TaskStateRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TaskStateRes>> AsyncCurrentRunning(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TaskStateRes>>(AsyncCurrentRunningRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TaskStateRes>> PrepareAsyncCurrentRunning(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TaskStateRes>>(PrepareAsyncCurrentRunningRaw(context, request, cq));
    }
    virtual ::grpc::Status StopCurrent(::grpc::ClientContext* context, const ::QueueReq& request, ::ExitRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>> AsyncStopCurrent(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>>(AsyncStopCurrentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>> PrepareAsyncStopCurrent(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>>(PrepareAsyncStopCurrentRaw(context, request, cq));
    }
    virtual ::grpc::Status StopAll(::grpc::ClientContext* context, const ::QueueReq& request, ::ExitRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>> AsyncStopAll(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>>(AsyncStopAllRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>> PrepareAsyncStopAll(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>>(PrepareAsyncStopAllRaw(context, request, cq));
    }
    virtual ::grpc::Status CurrentTaskOutput(::grpc::ClientContext* context, const ::QueueReq& request, ::CurrentTaskOutputRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CurrentTaskOutputRes>> AsyncCurrentTaskOutput(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CurrentTaskOutputRes>>(AsyncCurrentTaskOutputRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CurrentTaskOutputRes>> PrepareAsyncCurrentTaskOutput(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CurrentTaskOutputRes>>(PrepareAsyncCurrentTaskOutputRaw(context, request, cq));
    }
    // exited list
    virtual ::grpc::Status ListExitedTask(::grpc::ClientContext* context, const ::QueueReq& request, ::ListTaskRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ListTaskRes>> AsyncListExitedTask(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ListTaskRes>>(AsyncListExitedTaskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ListTaskRes>> PrepareAsyncListExitedTask(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ListTaskRes>>(PrepareAsyncListExitedTaskRaw(context, request, cq));
    }
    virtual ::grpc::Status TaskExitState(::grpc::ClientContext* context, const ::TaskIDReq& request, ::TaskExitStateRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TaskExitStateRes>> AsyncTaskExitState(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TaskExitStateRes>>(AsyncTaskExitStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TaskExitStateRes>> PrepareAsyncTaskExitState(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TaskExitStateRes>>(PrepareAsyncTaskExitStateRaw(context, request, cq));
    }
    // for file
    std::unique_ptr< ::grpc::ClientWriterInterface< ::File>> UploadHook(::grpc::ClientContext* context, ::FileRes* response) {
      return std::unique_ptr< ::grpc::ClientWriterInterface< ::File>>(UploadHookRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::File>> AsyncUploadHook(::grpc::ClientContext* context, ::FileRes* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::File>>(AsyncUploadHookRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::File>> PrepareAsyncUploadHook(::grpc::ClientContext* context, ::FileRes* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::File>>(PrepareAsyncUploadHookRaw(context, response, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::File>> DownloadLog(::grpc::ClientContext* context, const ::TaskIDReq& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::File>>(DownloadLogRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::File>> AsyncDownloadLog(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::File>>(AsyncDownloadLogRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::File>> PrepareAsyncDownloadLog(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::File>>(PrepareAsyncDownloadLogRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // for login
      virtual void Login(::grpc::ClientContext* context, const ::LoginReq* request, ::ExitRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Login(::grpc::ClientContext* context, const ::LoginReq* request, ::ExitRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Logout(::grpc::ClientContext* context, const ::Inquiry* request, ::ExitRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Logout(::grpc::ClientContext* context, const ::Inquiry* request, ::ExitRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // for queue
      virtual void CreateQueue(::grpc::ClientContext* context, const ::QueueReq* request, ::ExitRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateQueue(::grpc::ClientContext* context, const ::QueueReq* request, ::ExitRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DeleteQueue(::grpc::ClientContext* context, const ::QueueReq* request, ::ExitRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteQueue(::grpc::ClientContext* context, const ::QueueReq* request, ::ExitRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ListQueue(::grpc::ClientContext* context, const ::Inquiry* request, ::ListQueueRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListQueue(::grpc::ClientContext* context, const ::Inquiry* request, ::ListQueueRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // for task
      // panding list
      virtual void AddTask(::grpc::ClientContext* context, const ::AddTaskReq* request, ::ExitRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AddTask(::grpc::ClientContext* context, const ::AddTaskReq* request, ::ExitRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DeleteTask(::grpc::ClientContext* context, const ::TaskIDReq* request, ::ExitRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteTask(::grpc::ClientContext* context, const ::TaskIDReq* request, ::ExitRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ListTask(::grpc::ClientContext* context, const ::QueueReq* request, ::ListTaskRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListTask(::grpc::ClientContext* context, const ::QueueReq* request, ::ListTaskRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void TaskState(::grpc::ClientContext* context, const ::TaskIDReq* request, ::TaskStateRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TaskState(::grpc::ClientContext* context, const ::TaskIDReq* request, ::TaskStateRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // for current
      virtual void CurrentRunning(::grpc::ClientContext* context, const ::QueueReq* request, ::TaskStateRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CurrentRunning(::grpc::ClientContext* context, const ::QueueReq* request, ::TaskStateRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void StopCurrent(::grpc::ClientContext* context, const ::QueueReq* request, ::ExitRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopCurrent(::grpc::ClientContext* context, const ::QueueReq* request, ::ExitRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void StopAll(::grpc::ClientContext* context, const ::QueueReq* request, ::ExitRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopAll(::grpc::ClientContext* context, const ::QueueReq* request, ::ExitRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void CurrentTaskOutput(::grpc::ClientContext* context, const ::QueueReq* request, ::CurrentTaskOutputRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CurrentTaskOutput(::grpc::ClientContext* context, const ::QueueReq* request, ::CurrentTaskOutputRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // exited list
      virtual void ListExitedTask(::grpc::ClientContext* context, const ::QueueReq* request, ::ListTaskRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListExitedTask(::grpc::ClientContext* context, const ::QueueReq* request, ::ListTaskRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void TaskExitState(::grpc::ClientContext* context, const ::TaskIDReq* request, ::TaskExitStateRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TaskExitState(::grpc::ClientContext* context, const ::TaskIDReq* request, ::TaskExitStateRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // for file
      virtual void UploadHook(::grpc::ClientContext* context, ::FileRes* response, ::grpc::ClientWriteReactor< ::File>* reactor) = 0;
      virtual void DownloadLog(::grpc::ClientContext* context, const ::TaskIDReq* request, ::grpc::ClientReadReactor< ::File>* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>* AsyncLoginRaw(::grpc::ClientContext* context, const ::LoginReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>* PrepareAsyncLoginRaw(::grpc::ClientContext* context, const ::LoginReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>* AsyncLogoutRaw(::grpc::ClientContext* context, const ::Inquiry& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>* PrepareAsyncLogoutRaw(::grpc::ClientContext* context, const ::Inquiry& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>* AsyncCreateQueueRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>* PrepareAsyncCreateQueueRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>* AsyncDeleteQueueRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>* PrepareAsyncDeleteQueueRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ListQueueRes>* AsyncListQueueRaw(::grpc::ClientContext* context, const ::Inquiry& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ListQueueRes>* PrepareAsyncListQueueRaw(::grpc::ClientContext* context, const ::Inquiry& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>* AsyncAddTaskRaw(::grpc::ClientContext* context, const ::AddTaskReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>* PrepareAsyncAddTaskRaw(::grpc::ClientContext* context, const ::AddTaskReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>* AsyncDeleteTaskRaw(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>* PrepareAsyncDeleteTaskRaw(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ListTaskRes>* AsyncListTaskRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ListTaskRes>* PrepareAsyncListTaskRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TaskStateRes>* AsyncTaskStateRaw(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TaskStateRes>* PrepareAsyncTaskStateRaw(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TaskStateRes>* AsyncCurrentRunningRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TaskStateRes>* PrepareAsyncCurrentRunningRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>* AsyncStopCurrentRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>* PrepareAsyncStopCurrentRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>* AsyncStopAllRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ExitRes>* PrepareAsyncStopAllRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CurrentTaskOutputRes>* AsyncCurrentTaskOutputRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CurrentTaskOutputRes>* PrepareAsyncCurrentTaskOutputRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ListTaskRes>* AsyncListExitedTaskRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ListTaskRes>* PrepareAsyncListExitedTaskRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TaskExitStateRes>* AsyncTaskExitStateRaw(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TaskExitStateRes>* PrepareAsyncTaskExitStateRaw(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientWriterInterface< ::File>* UploadHookRaw(::grpc::ClientContext* context, ::FileRes* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::File>* AsyncUploadHookRaw(::grpc::ClientContext* context, ::FileRes* response, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::File>* PrepareAsyncUploadHookRaw(::grpc::ClientContext* context, ::FileRes* response, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::File>* DownloadLogRaw(::grpc::ClientContext* context, const ::TaskIDReq& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::File>* AsyncDownloadLogRaw(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::File>* PrepareAsyncDownloadLogRaw(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Login(::grpc::ClientContext* context, const ::LoginReq& request, ::ExitRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>> AsyncLogin(::grpc::ClientContext* context, const ::LoginReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>>(AsyncLoginRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>> PrepareAsyncLogin(::grpc::ClientContext* context, const ::LoginReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>>(PrepareAsyncLoginRaw(context, request, cq));
    }
    ::grpc::Status Logout(::grpc::ClientContext* context, const ::Inquiry& request, ::ExitRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>> AsyncLogout(::grpc::ClientContext* context, const ::Inquiry& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>>(AsyncLogoutRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>> PrepareAsyncLogout(::grpc::ClientContext* context, const ::Inquiry& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>>(PrepareAsyncLogoutRaw(context, request, cq));
    }
    ::grpc::Status CreateQueue(::grpc::ClientContext* context, const ::QueueReq& request, ::ExitRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>> AsyncCreateQueue(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>>(AsyncCreateQueueRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>> PrepareAsyncCreateQueue(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>>(PrepareAsyncCreateQueueRaw(context, request, cq));
    }
    ::grpc::Status DeleteQueue(::grpc::ClientContext* context, const ::QueueReq& request, ::ExitRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>> AsyncDeleteQueue(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>>(AsyncDeleteQueueRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>> PrepareAsyncDeleteQueue(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>>(PrepareAsyncDeleteQueueRaw(context, request, cq));
    }
    ::grpc::Status ListQueue(::grpc::ClientContext* context, const ::Inquiry& request, ::ListQueueRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ListQueueRes>> AsyncListQueue(::grpc::ClientContext* context, const ::Inquiry& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ListQueueRes>>(AsyncListQueueRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ListQueueRes>> PrepareAsyncListQueue(::grpc::ClientContext* context, const ::Inquiry& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ListQueueRes>>(PrepareAsyncListQueueRaw(context, request, cq));
    }
    ::grpc::Status AddTask(::grpc::ClientContext* context, const ::AddTaskReq& request, ::ExitRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>> AsyncAddTask(::grpc::ClientContext* context, const ::AddTaskReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>>(AsyncAddTaskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>> PrepareAsyncAddTask(::grpc::ClientContext* context, const ::AddTaskReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>>(PrepareAsyncAddTaskRaw(context, request, cq));
    }
    ::grpc::Status DeleteTask(::grpc::ClientContext* context, const ::TaskIDReq& request, ::ExitRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>> AsyncDeleteTask(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>>(AsyncDeleteTaskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>> PrepareAsyncDeleteTask(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>>(PrepareAsyncDeleteTaskRaw(context, request, cq));
    }
    ::grpc::Status ListTask(::grpc::ClientContext* context, const ::QueueReq& request, ::ListTaskRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ListTaskRes>> AsyncListTask(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ListTaskRes>>(AsyncListTaskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ListTaskRes>> PrepareAsyncListTask(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ListTaskRes>>(PrepareAsyncListTaskRaw(context, request, cq));
    }
    ::grpc::Status TaskState(::grpc::ClientContext* context, const ::TaskIDReq& request, ::TaskStateRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TaskStateRes>> AsyncTaskState(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TaskStateRes>>(AsyncTaskStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TaskStateRes>> PrepareAsyncTaskState(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TaskStateRes>>(PrepareAsyncTaskStateRaw(context, request, cq));
    }
    ::grpc::Status CurrentRunning(::grpc::ClientContext* context, const ::QueueReq& request, ::TaskStateRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TaskStateRes>> AsyncCurrentRunning(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TaskStateRes>>(AsyncCurrentRunningRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TaskStateRes>> PrepareAsyncCurrentRunning(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TaskStateRes>>(PrepareAsyncCurrentRunningRaw(context, request, cq));
    }
    ::grpc::Status StopCurrent(::grpc::ClientContext* context, const ::QueueReq& request, ::ExitRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>> AsyncStopCurrent(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>>(AsyncStopCurrentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>> PrepareAsyncStopCurrent(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>>(PrepareAsyncStopCurrentRaw(context, request, cq));
    }
    ::grpc::Status StopAll(::grpc::ClientContext* context, const ::QueueReq& request, ::ExitRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>> AsyncStopAll(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>>(AsyncStopAllRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>> PrepareAsyncStopAll(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ExitRes>>(PrepareAsyncStopAllRaw(context, request, cq));
    }
    ::grpc::Status CurrentTaskOutput(::grpc::ClientContext* context, const ::QueueReq& request, ::CurrentTaskOutputRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CurrentTaskOutputRes>> AsyncCurrentTaskOutput(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CurrentTaskOutputRes>>(AsyncCurrentTaskOutputRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CurrentTaskOutputRes>> PrepareAsyncCurrentTaskOutput(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CurrentTaskOutputRes>>(PrepareAsyncCurrentTaskOutputRaw(context, request, cq));
    }
    ::grpc::Status ListExitedTask(::grpc::ClientContext* context, const ::QueueReq& request, ::ListTaskRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ListTaskRes>> AsyncListExitedTask(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ListTaskRes>>(AsyncListExitedTaskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ListTaskRes>> PrepareAsyncListExitedTask(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ListTaskRes>>(PrepareAsyncListExitedTaskRaw(context, request, cq));
    }
    ::grpc::Status TaskExitState(::grpc::ClientContext* context, const ::TaskIDReq& request, ::TaskExitStateRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TaskExitStateRes>> AsyncTaskExitState(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TaskExitStateRes>>(AsyncTaskExitStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TaskExitStateRes>> PrepareAsyncTaskExitState(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TaskExitStateRes>>(PrepareAsyncTaskExitStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientWriter< ::File>> UploadHook(::grpc::ClientContext* context, ::FileRes* response) {
      return std::unique_ptr< ::grpc::ClientWriter< ::File>>(UploadHookRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::File>> AsyncUploadHook(::grpc::ClientContext* context, ::FileRes* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::File>>(AsyncUploadHookRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::File>> PrepareAsyncUploadHook(::grpc::ClientContext* context, ::FileRes* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::File>>(PrepareAsyncUploadHookRaw(context, response, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::File>> DownloadLog(::grpc::ClientContext* context, const ::TaskIDReq& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::File>>(DownloadLogRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::File>> AsyncDownloadLog(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::File>>(AsyncDownloadLogRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::File>> PrepareAsyncDownloadLog(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::File>>(PrepareAsyncDownloadLogRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Login(::grpc::ClientContext* context, const ::LoginReq* request, ::ExitRes* response, std::function<void(::grpc::Status)>) override;
      void Login(::grpc::ClientContext* context, const ::LoginReq* request, ::ExitRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Logout(::grpc::ClientContext* context, const ::Inquiry* request, ::ExitRes* response, std::function<void(::grpc::Status)>) override;
      void Logout(::grpc::ClientContext* context, const ::Inquiry* request, ::ExitRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CreateQueue(::grpc::ClientContext* context, const ::QueueReq* request, ::ExitRes* response, std::function<void(::grpc::Status)>) override;
      void CreateQueue(::grpc::ClientContext* context, const ::QueueReq* request, ::ExitRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DeleteQueue(::grpc::ClientContext* context, const ::QueueReq* request, ::ExitRes* response, std::function<void(::grpc::Status)>) override;
      void DeleteQueue(::grpc::ClientContext* context, const ::QueueReq* request, ::ExitRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ListQueue(::grpc::ClientContext* context, const ::Inquiry* request, ::ListQueueRes* response, std::function<void(::grpc::Status)>) override;
      void ListQueue(::grpc::ClientContext* context, const ::Inquiry* request, ::ListQueueRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void AddTask(::grpc::ClientContext* context, const ::AddTaskReq* request, ::ExitRes* response, std::function<void(::grpc::Status)>) override;
      void AddTask(::grpc::ClientContext* context, const ::AddTaskReq* request, ::ExitRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DeleteTask(::grpc::ClientContext* context, const ::TaskIDReq* request, ::ExitRes* response, std::function<void(::grpc::Status)>) override;
      void DeleteTask(::grpc::ClientContext* context, const ::TaskIDReq* request, ::ExitRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ListTask(::grpc::ClientContext* context, const ::QueueReq* request, ::ListTaskRes* response, std::function<void(::grpc::Status)>) override;
      void ListTask(::grpc::ClientContext* context, const ::QueueReq* request, ::ListTaskRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void TaskState(::grpc::ClientContext* context, const ::TaskIDReq* request, ::TaskStateRes* response, std::function<void(::grpc::Status)>) override;
      void TaskState(::grpc::ClientContext* context, const ::TaskIDReq* request, ::TaskStateRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CurrentRunning(::grpc::ClientContext* context, const ::QueueReq* request, ::TaskStateRes* response, std::function<void(::grpc::Status)>) override;
      void CurrentRunning(::grpc::ClientContext* context, const ::QueueReq* request, ::TaskStateRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StopCurrent(::grpc::ClientContext* context, const ::QueueReq* request, ::ExitRes* response, std::function<void(::grpc::Status)>) override;
      void StopCurrent(::grpc::ClientContext* context, const ::QueueReq* request, ::ExitRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StopAll(::grpc::ClientContext* context, const ::QueueReq* request, ::ExitRes* response, std::function<void(::grpc::Status)>) override;
      void StopAll(::grpc::ClientContext* context, const ::QueueReq* request, ::ExitRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CurrentTaskOutput(::grpc::ClientContext* context, const ::QueueReq* request, ::CurrentTaskOutputRes* response, std::function<void(::grpc::Status)>) override;
      void CurrentTaskOutput(::grpc::ClientContext* context, const ::QueueReq* request, ::CurrentTaskOutputRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ListExitedTask(::grpc::ClientContext* context, const ::QueueReq* request, ::ListTaskRes* response, std::function<void(::grpc::Status)>) override;
      void ListExitedTask(::grpc::ClientContext* context, const ::QueueReq* request, ::ListTaskRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void TaskExitState(::grpc::ClientContext* context, const ::TaskIDReq* request, ::TaskExitStateRes* response, std::function<void(::grpc::Status)>) override;
      void TaskExitState(::grpc::ClientContext* context, const ::TaskIDReq* request, ::TaskExitStateRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UploadHook(::grpc::ClientContext* context, ::FileRes* response, ::grpc::ClientWriteReactor< ::File>* reactor) override;
      void DownloadLog(::grpc::ClientContext* context, const ::TaskIDReq* request, ::grpc::ClientReadReactor< ::File>* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::ExitRes>* AsyncLoginRaw(::grpc::ClientContext* context, const ::LoginReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ExitRes>* PrepareAsyncLoginRaw(::grpc::ClientContext* context, const ::LoginReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ExitRes>* AsyncLogoutRaw(::grpc::ClientContext* context, const ::Inquiry& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ExitRes>* PrepareAsyncLogoutRaw(::grpc::ClientContext* context, const ::Inquiry& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ExitRes>* AsyncCreateQueueRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ExitRes>* PrepareAsyncCreateQueueRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ExitRes>* AsyncDeleteQueueRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ExitRes>* PrepareAsyncDeleteQueueRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ListQueueRes>* AsyncListQueueRaw(::grpc::ClientContext* context, const ::Inquiry& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ListQueueRes>* PrepareAsyncListQueueRaw(::grpc::ClientContext* context, const ::Inquiry& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ExitRes>* AsyncAddTaskRaw(::grpc::ClientContext* context, const ::AddTaskReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ExitRes>* PrepareAsyncAddTaskRaw(::grpc::ClientContext* context, const ::AddTaskReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ExitRes>* AsyncDeleteTaskRaw(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ExitRes>* PrepareAsyncDeleteTaskRaw(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ListTaskRes>* AsyncListTaskRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ListTaskRes>* PrepareAsyncListTaskRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TaskStateRes>* AsyncTaskStateRaw(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TaskStateRes>* PrepareAsyncTaskStateRaw(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TaskStateRes>* AsyncCurrentRunningRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TaskStateRes>* PrepareAsyncCurrentRunningRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ExitRes>* AsyncStopCurrentRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ExitRes>* PrepareAsyncStopCurrentRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ExitRes>* AsyncStopAllRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ExitRes>* PrepareAsyncStopAllRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CurrentTaskOutputRes>* AsyncCurrentTaskOutputRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CurrentTaskOutputRes>* PrepareAsyncCurrentTaskOutputRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ListTaskRes>* AsyncListExitedTaskRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ListTaskRes>* PrepareAsyncListExitedTaskRaw(::grpc::ClientContext* context, const ::QueueReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TaskExitStateRes>* AsyncTaskExitStateRaw(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TaskExitStateRes>* PrepareAsyncTaskExitStateRaw(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientWriter< ::File>* UploadHookRaw(::grpc::ClientContext* context, ::FileRes* response) override;
    ::grpc::ClientAsyncWriter< ::File>* AsyncUploadHookRaw(::grpc::ClientContext* context, ::FileRes* response, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter< ::File>* PrepareAsyncUploadHookRaw(::grpc::ClientContext* context, ::FileRes* response, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::File>* DownloadLogRaw(::grpc::ClientContext* context, const ::TaskIDReq& request) override;
    ::grpc::ClientAsyncReader< ::File>* AsyncDownloadLogRaw(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::File>* PrepareAsyncDownloadLogRaw(::grpc::ClientContext* context, const ::TaskIDReq& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Login_;
    const ::grpc::internal::RpcMethod rpcmethod_Logout_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateQueue_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteQueue_;
    const ::grpc::internal::RpcMethod rpcmethod_ListQueue_;
    const ::grpc::internal::RpcMethod rpcmethod_AddTask_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteTask_;
    const ::grpc::internal::RpcMethod rpcmethod_ListTask_;
    const ::grpc::internal::RpcMethod rpcmethod_TaskState_;
    const ::grpc::internal::RpcMethod rpcmethod_CurrentRunning_;
    const ::grpc::internal::RpcMethod rpcmethod_StopCurrent_;
    const ::grpc::internal::RpcMethod rpcmethod_StopAll_;
    const ::grpc::internal::RpcMethod rpcmethod_CurrentTaskOutput_;
    const ::grpc::internal::RpcMethod rpcmethod_ListExitedTask_;
    const ::grpc::internal::RpcMethod rpcmethod_TaskExitState_;
    const ::grpc::internal::RpcMethod rpcmethod_UploadHook_;
    const ::grpc::internal::RpcMethod rpcmethod_DownloadLog_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // for login
    virtual ::grpc::Status Login(::grpc::ServerContext* context, const ::LoginReq* request, ::ExitRes* response);
    virtual ::grpc::Status Logout(::grpc::ServerContext* context, const ::Inquiry* request, ::ExitRes* response);
    // for queue
    virtual ::grpc::Status CreateQueue(::grpc::ServerContext* context, const ::QueueReq* request, ::ExitRes* response);
    virtual ::grpc::Status DeleteQueue(::grpc::ServerContext* context, const ::QueueReq* request, ::ExitRes* response);
    virtual ::grpc::Status ListQueue(::grpc::ServerContext* context, const ::Inquiry* request, ::ListQueueRes* response);
    // for task
    // panding list
    virtual ::grpc::Status AddTask(::grpc::ServerContext* context, const ::AddTaskReq* request, ::ExitRes* response);
    virtual ::grpc::Status DeleteTask(::grpc::ServerContext* context, const ::TaskIDReq* request, ::ExitRes* response);
    virtual ::grpc::Status ListTask(::grpc::ServerContext* context, const ::QueueReq* request, ::ListTaskRes* response);
    virtual ::grpc::Status TaskState(::grpc::ServerContext* context, const ::TaskIDReq* request, ::TaskStateRes* response);
    // for current
    virtual ::grpc::Status CurrentRunning(::grpc::ServerContext* context, const ::QueueReq* request, ::TaskStateRes* response);
    virtual ::grpc::Status StopCurrent(::grpc::ServerContext* context, const ::QueueReq* request, ::ExitRes* response);
    virtual ::grpc::Status StopAll(::grpc::ServerContext* context, const ::QueueReq* request, ::ExitRes* response);
    virtual ::grpc::Status CurrentTaskOutput(::grpc::ServerContext* context, const ::QueueReq* request, ::CurrentTaskOutputRes* response);
    // exited list
    virtual ::grpc::Status ListExitedTask(::grpc::ServerContext* context, const ::QueueReq* request, ::ListTaskRes* response);
    virtual ::grpc::Status TaskExitState(::grpc::ServerContext* context, const ::TaskIDReq* request, ::TaskExitStateRes* response);
    // for file
    virtual ::grpc::Status UploadHook(::grpc::ServerContext* context, ::grpc::ServerReader< ::File>* reader, ::FileRes* response);
    virtual ::grpc::Status DownloadLog(::grpc::ServerContext* context, const ::TaskIDReq* request, ::grpc::ServerWriter< ::File>* writer);
  };
  template <class BaseClass>
  class WithAsyncMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Login() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::LoginReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLogin(::grpc::ServerContext* context, ::LoginReq* request, ::grpc::ServerAsyncResponseWriter< ::ExitRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Logout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Logout() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Logout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Logout(::grpc::ServerContext* /*context*/, const ::Inquiry* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLogout(::grpc::ServerContext* context, ::Inquiry* request, ::grpc::ServerAsyncResponseWriter< ::ExitRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateQueue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateQueue() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_CreateQueue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateQueue(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateQueue(::grpc::ServerContext* context, ::QueueReq* request, ::grpc::ServerAsyncResponseWriter< ::ExitRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteQueue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteQueue() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_DeleteQueue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteQueue(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteQueue(::grpc::ServerContext* context, ::QueueReq* request, ::grpc::ServerAsyncResponseWriter< ::ExitRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListQueue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListQueue() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_ListQueue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListQueue(::grpc::ServerContext* /*context*/, const ::Inquiry* /*request*/, ::ListQueueRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListQueue(::grpc::ServerContext* context, ::Inquiry* request, ::grpc::ServerAsyncResponseWriter< ::ListQueueRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddTask() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_AddTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddTask(::grpc::ServerContext* /*context*/, const ::AddTaskReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddTask(::grpc::ServerContext* context, ::AddTaskReq* request, ::grpc::ServerAsyncResponseWriter< ::ExitRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteTask() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_DeleteTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteTask(::grpc::ServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteTask(::grpc::ServerContext* context, ::TaskIDReq* request, ::grpc::ServerAsyncResponseWriter< ::ExitRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListTask() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_ListTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTask(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ListTaskRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListTask(::grpc::ServerContext* context, ::QueueReq* request, ::grpc::ServerAsyncResponseWriter< ::ListTaskRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TaskState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TaskState() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_TaskState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TaskState(::grpc::ServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::TaskStateRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTaskState(::grpc::ServerContext* context, ::TaskIDReq* request, ::grpc::ServerAsyncResponseWriter< ::TaskStateRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CurrentRunning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CurrentRunning() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_CurrentRunning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CurrentRunning(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::TaskStateRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCurrentRunning(::grpc::ServerContext* context, ::QueueReq* request, ::grpc::ServerAsyncResponseWriter< ::TaskStateRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopCurrent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StopCurrent() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_StopCurrent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopCurrent(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopCurrent(::grpc::ServerContext* context, ::QueueReq* request, ::grpc::ServerAsyncResponseWriter< ::ExitRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StopAll() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_StopAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopAll(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopAll(::grpc::ServerContext* context, ::QueueReq* request, ::grpc::ServerAsyncResponseWriter< ::ExitRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CurrentTaskOutput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CurrentTaskOutput() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_CurrentTaskOutput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CurrentTaskOutput(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::CurrentTaskOutputRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCurrentTaskOutput(::grpc::ServerContext* context, ::QueueReq* request, ::grpc::ServerAsyncResponseWriter< ::CurrentTaskOutputRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListExitedTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListExitedTask() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_ListExitedTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListExitedTask(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ListTaskRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListExitedTask(::grpc::ServerContext* context, ::QueueReq* request, ::grpc::ServerAsyncResponseWriter< ::ListTaskRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TaskExitState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TaskExitState() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_TaskExitState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TaskExitState(::grpc::ServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::TaskExitStateRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTaskExitState(::grpc::ServerContext* context, ::TaskIDReq* request, ::grpc::ServerAsyncResponseWriter< ::TaskExitStateRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UploadHook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UploadHook() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_UploadHook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadHook(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::File>* /*reader*/, ::FileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadHook(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::FileRes, ::File>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(15, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DownloadLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DownloadLog() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_DownloadLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadLog(::grpc::ServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::grpc::ServerWriter< ::File>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDownloadLog(::grpc::ServerContext* context, ::TaskIDReq* request, ::grpc::ServerAsyncWriter< ::File>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(16, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Login<WithAsyncMethod_Logout<WithAsyncMethod_CreateQueue<WithAsyncMethod_DeleteQueue<WithAsyncMethod_ListQueue<WithAsyncMethod_AddTask<WithAsyncMethod_DeleteTask<WithAsyncMethod_ListTask<WithAsyncMethod_TaskState<WithAsyncMethod_CurrentRunning<WithAsyncMethod_StopCurrent<WithAsyncMethod_StopAll<WithAsyncMethod_CurrentTaskOutput<WithAsyncMethod_ListExitedTask<WithAsyncMethod_TaskExitState<WithAsyncMethod_UploadHook<WithAsyncMethod_DownloadLog<Service > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Login() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::LoginReq, ::ExitRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::LoginReq* request, ::ExitRes* response) { return this->Login(context, request, response); }));}
    void SetMessageAllocatorFor_Login(
        ::grpc::MessageAllocator< ::LoginReq, ::ExitRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::LoginReq, ::ExitRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::LoginReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Login(
      ::grpc::CallbackServerContext* /*context*/, const ::LoginReq* /*request*/, ::ExitRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Logout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Logout() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::Inquiry, ::ExitRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Inquiry* request, ::ExitRes* response) { return this->Logout(context, request, response); }));}
    void SetMessageAllocatorFor_Logout(
        ::grpc::MessageAllocator< ::Inquiry, ::ExitRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Inquiry, ::ExitRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Logout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Logout(::grpc::ServerContext* /*context*/, const ::Inquiry* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Logout(
      ::grpc::CallbackServerContext* /*context*/, const ::Inquiry* /*request*/, ::ExitRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CreateQueue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CreateQueue() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::QueueReq, ::ExitRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::QueueReq* request, ::ExitRes* response) { return this->CreateQueue(context, request, response); }));}
    void SetMessageAllocatorFor_CreateQueue(
        ::grpc::MessageAllocator< ::QueueReq, ::ExitRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::QueueReq, ::ExitRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CreateQueue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateQueue(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateQueue(
      ::grpc::CallbackServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DeleteQueue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DeleteQueue() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::QueueReq, ::ExitRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::QueueReq* request, ::ExitRes* response) { return this->DeleteQueue(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteQueue(
        ::grpc::MessageAllocator< ::QueueReq, ::ExitRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::QueueReq, ::ExitRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DeleteQueue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteQueue(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteQueue(
      ::grpc::CallbackServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListQueue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListQueue() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::Inquiry, ::ListQueueRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Inquiry* request, ::ListQueueRes* response) { return this->ListQueue(context, request, response); }));}
    void SetMessageAllocatorFor_ListQueue(
        ::grpc::MessageAllocator< ::Inquiry, ::ListQueueRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Inquiry, ::ListQueueRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListQueue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListQueue(::grpc::ServerContext* /*context*/, const ::Inquiry* /*request*/, ::ListQueueRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListQueue(
      ::grpc::CallbackServerContext* /*context*/, const ::Inquiry* /*request*/, ::ListQueueRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AddTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AddTask() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::AddTaskReq, ::ExitRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::AddTaskReq* request, ::ExitRes* response) { return this->AddTask(context, request, response); }));}
    void SetMessageAllocatorFor_AddTask(
        ::grpc::MessageAllocator< ::AddTaskReq, ::ExitRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::AddTaskReq, ::ExitRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AddTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddTask(::grpc::ServerContext* /*context*/, const ::AddTaskReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AddTask(
      ::grpc::CallbackServerContext* /*context*/, const ::AddTaskReq* /*request*/, ::ExitRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DeleteTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DeleteTask() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::TaskIDReq, ::ExitRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TaskIDReq* request, ::ExitRes* response) { return this->DeleteTask(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteTask(
        ::grpc::MessageAllocator< ::TaskIDReq, ::ExitRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::TaskIDReq, ::ExitRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DeleteTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteTask(::grpc::ServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteTask(
      ::grpc::CallbackServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::ExitRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListTask() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::QueueReq, ::ListTaskRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::QueueReq* request, ::ListTaskRes* response) { return this->ListTask(context, request, response); }));}
    void SetMessageAllocatorFor_ListTask(
        ::grpc::MessageAllocator< ::QueueReq, ::ListTaskRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::QueueReq, ::ListTaskRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTask(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ListTaskRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListTask(
      ::grpc::CallbackServerContext* /*context*/, const ::QueueReq* /*request*/, ::ListTaskRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_TaskState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_TaskState() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::TaskIDReq, ::TaskStateRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TaskIDReq* request, ::TaskStateRes* response) { return this->TaskState(context, request, response); }));}
    void SetMessageAllocatorFor_TaskState(
        ::grpc::MessageAllocator< ::TaskIDReq, ::TaskStateRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::TaskIDReq, ::TaskStateRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_TaskState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TaskState(::grpc::ServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::TaskStateRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TaskState(
      ::grpc::CallbackServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::TaskStateRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CurrentRunning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CurrentRunning() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::QueueReq, ::TaskStateRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::QueueReq* request, ::TaskStateRes* response) { return this->CurrentRunning(context, request, response); }));}
    void SetMessageAllocatorFor_CurrentRunning(
        ::grpc::MessageAllocator< ::QueueReq, ::TaskStateRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::QueueReq, ::TaskStateRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CurrentRunning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CurrentRunning(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::TaskStateRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CurrentRunning(
      ::grpc::CallbackServerContext* /*context*/, const ::QueueReq* /*request*/, ::TaskStateRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StopCurrent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StopCurrent() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::QueueReq, ::ExitRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::QueueReq* request, ::ExitRes* response) { return this->StopCurrent(context, request, response); }));}
    void SetMessageAllocatorFor_StopCurrent(
        ::grpc::MessageAllocator< ::QueueReq, ::ExitRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::QueueReq, ::ExitRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StopCurrent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopCurrent(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopCurrent(
      ::grpc::CallbackServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StopAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StopAll() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::QueueReq, ::ExitRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::QueueReq* request, ::ExitRes* response) { return this->StopAll(context, request, response); }));}
    void SetMessageAllocatorFor_StopAll(
        ::grpc::MessageAllocator< ::QueueReq, ::ExitRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::QueueReq, ::ExitRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StopAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopAll(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopAll(
      ::grpc::CallbackServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CurrentTaskOutput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CurrentTaskOutput() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::QueueReq, ::CurrentTaskOutputRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::QueueReq* request, ::CurrentTaskOutputRes* response) { return this->CurrentTaskOutput(context, request, response); }));}
    void SetMessageAllocatorFor_CurrentTaskOutput(
        ::grpc::MessageAllocator< ::QueueReq, ::CurrentTaskOutputRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::QueueReq, ::CurrentTaskOutputRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CurrentTaskOutput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CurrentTaskOutput(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::CurrentTaskOutputRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CurrentTaskOutput(
      ::grpc::CallbackServerContext* /*context*/, const ::QueueReq* /*request*/, ::CurrentTaskOutputRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListExitedTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListExitedTask() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::QueueReq, ::ListTaskRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::QueueReq* request, ::ListTaskRes* response) { return this->ListExitedTask(context, request, response); }));}
    void SetMessageAllocatorFor_ListExitedTask(
        ::grpc::MessageAllocator< ::QueueReq, ::ListTaskRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::QueueReq, ::ListTaskRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListExitedTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListExitedTask(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ListTaskRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListExitedTask(
      ::grpc::CallbackServerContext* /*context*/, const ::QueueReq* /*request*/, ::ListTaskRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_TaskExitState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_TaskExitState() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::TaskIDReq, ::TaskExitStateRes>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TaskIDReq* request, ::TaskExitStateRes* response) { return this->TaskExitState(context, request, response); }));}
    void SetMessageAllocatorFor_TaskExitState(
        ::grpc::MessageAllocator< ::TaskIDReq, ::TaskExitStateRes>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::TaskIDReq, ::TaskExitStateRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_TaskExitState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TaskExitState(::grpc::ServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::TaskExitStateRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TaskExitState(
      ::grpc::CallbackServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::TaskExitStateRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UploadHook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UploadHook() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackClientStreamingHandler< ::File, ::FileRes>(
            [this](
                   ::grpc::CallbackServerContext* context, ::FileRes* response) { return this->UploadHook(context, response); }));
    }
    ~WithCallbackMethod_UploadHook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadHook(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::File>* /*reader*/, ::FileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor< ::File>* UploadHook(
      ::grpc::CallbackServerContext* /*context*/, ::FileRes* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DownloadLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DownloadLog() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackServerStreamingHandler< ::TaskIDReq, ::File>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TaskIDReq* request) { return this->DownloadLog(context, request); }));
    }
    ~WithCallbackMethod_DownloadLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadLog(::grpc::ServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::grpc::ServerWriter< ::File>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::File>* DownloadLog(
      ::grpc::CallbackServerContext* /*context*/, const ::TaskIDReq* /*request*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Login<WithCallbackMethod_Logout<WithCallbackMethod_CreateQueue<WithCallbackMethod_DeleteQueue<WithCallbackMethod_ListQueue<WithCallbackMethod_AddTask<WithCallbackMethod_DeleteTask<WithCallbackMethod_ListTask<WithCallbackMethod_TaskState<WithCallbackMethod_CurrentRunning<WithCallbackMethod_StopCurrent<WithCallbackMethod_StopAll<WithCallbackMethod_CurrentTaskOutput<WithCallbackMethod_ListExitedTask<WithCallbackMethod_TaskExitState<WithCallbackMethod_UploadHook<WithCallbackMethod_DownloadLog<Service > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Login() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::LoginReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Logout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Logout() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Logout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Logout(::grpc::ServerContext* /*context*/, const ::Inquiry* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateQueue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateQueue() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_CreateQueue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateQueue(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteQueue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteQueue() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_DeleteQueue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteQueue(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListQueue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListQueue() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_ListQueue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListQueue(::grpc::ServerContext* /*context*/, const ::Inquiry* /*request*/, ::ListQueueRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddTask() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_AddTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddTask(::grpc::ServerContext* /*context*/, const ::AddTaskReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteTask() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_DeleteTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteTask(::grpc::ServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListTask() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_ListTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTask(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ListTaskRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TaskState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TaskState() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_TaskState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TaskState(::grpc::ServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::TaskStateRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CurrentRunning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CurrentRunning() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_CurrentRunning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CurrentRunning(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::TaskStateRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopCurrent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StopCurrent() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_StopCurrent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopCurrent(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StopAll() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_StopAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopAll(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CurrentTaskOutput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CurrentTaskOutput() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_CurrentTaskOutput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CurrentTaskOutput(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::CurrentTaskOutputRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListExitedTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListExitedTask() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_ListExitedTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListExitedTask(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ListTaskRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TaskExitState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TaskExitState() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_TaskExitState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TaskExitState(::grpc::ServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::TaskExitStateRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UploadHook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UploadHook() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_UploadHook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadHook(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::File>* /*reader*/, ::FileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DownloadLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DownloadLog() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_DownloadLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadLog(::grpc::ServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::grpc::ServerWriter< ::File>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Login() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::LoginReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLogin(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Logout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Logout() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Logout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Logout(::grpc::ServerContext* /*context*/, const ::Inquiry* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLogout(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateQueue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateQueue() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_CreateQueue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateQueue(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateQueue(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteQueue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteQueue() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_DeleteQueue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteQueue(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteQueue(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListQueue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListQueue() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_ListQueue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListQueue(::grpc::ServerContext* /*context*/, const ::Inquiry* /*request*/, ::ListQueueRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListQueue(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddTask() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_AddTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddTask(::grpc::ServerContext* /*context*/, const ::AddTaskReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddTask(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteTask() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_DeleteTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteTask(::grpc::ServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteTask(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListTask() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_ListTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTask(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ListTaskRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListTask(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TaskState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TaskState() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_TaskState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TaskState(::grpc::ServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::TaskStateRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTaskState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CurrentRunning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CurrentRunning() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_CurrentRunning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CurrentRunning(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::TaskStateRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCurrentRunning(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopCurrent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StopCurrent() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_StopCurrent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopCurrent(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopCurrent(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StopAll() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_StopAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopAll(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopAll(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CurrentTaskOutput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CurrentTaskOutput() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_CurrentTaskOutput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CurrentTaskOutput(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::CurrentTaskOutputRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCurrentTaskOutput(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListExitedTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListExitedTask() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_ListExitedTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListExitedTask(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ListTaskRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListExitedTask(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TaskExitState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TaskExitState() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_TaskExitState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TaskExitState(::grpc::ServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::TaskExitStateRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTaskExitState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UploadHook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UploadHook() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_UploadHook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadHook(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::File>* /*reader*/, ::FileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadHook(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(15, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DownloadLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DownloadLog() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_DownloadLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadLog(::grpc::ServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::grpc::ServerWriter< ::File>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDownloadLog(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(16, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Login() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Login(context, request, response); }));
    }
    ~WithRawCallbackMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::LoginReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Login(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Logout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Logout() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Logout(context, request, response); }));
    }
    ~WithRawCallbackMethod_Logout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Logout(::grpc::ServerContext* /*context*/, const ::Inquiry* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Logout(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CreateQueue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CreateQueue() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateQueue(context, request, response); }));
    }
    ~WithRawCallbackMethod_CreateQueue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateQueue(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateQueue(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DeleteQueue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DeleteQueue() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteQueue(context, request, response); }));
    }
    ~WithRawCallbackMethod_DeleteQueue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteQueue(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteQueue(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListQueue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListQueue() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListQueue(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListQueue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListQueue(::grpc::ServerContext* /*context*/, const ::Inquiry* /*request*/, ::ListQueueRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListQueue(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AddTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AddTask() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddTask(context, request, response); }));
    }
    ~WithRawCallbackMethod_AddTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddTask(::grpc::ServerContext* /*context*/, const ::AddTaskReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AddTask(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DeleteTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DeleteTask() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteTask(context, request, response); }));
    }
    ~WithRawCallbackMethod_DeleteTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteTask(::grpc::ServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteTask(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListTask() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListTask(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTask(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ListTaskRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListTask(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_TaskState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_TaskState() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TaskState(context, request, response); }));
    }
    ~WithRawCallbackMethod_TaskState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TaskState(::grpc::ServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::TaskStateRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TaskState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CurrentRunning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CurrentRunning() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CurrentRunning(context, request, response); }));
    }
    ~WithRawCallbackMethod_CurrentRunning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CurrentRunning(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::TaskStateRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CurrentRunning(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StopCurrent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StopCurrent() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StopCurrent(context, request, response); }));
    }
    ~WithRawCallbackMethod_StopCurrent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopCurrent(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopCurrent(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StopAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StopAll() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StopAll(context, request, response); }));
    }
    ~WithRawCallbackMethod_StopAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopAll(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopAll(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CurrentTaskOutput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CurrentTaskOutput() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CurrentTaskOutput(context, request, response); }));
    }
    ~WithRawCallbackMethod_CurrentTaskOutput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CurrentTaskOutput(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::CurrentTaskOutputRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CurrentTaskOutput(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListExitedTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListExitedTask() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListExitedTask(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListExitedTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListExitedTask(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ListTaskRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListExitedTask(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_TaskExitState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_TaskExitState() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TaskExitState(context, request, response); }));
    }
    ~WithRawCallbackMethod_TaskExitState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TaskExitState(::grpc::ServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::TaskExitStateRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TaskExitState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UploadHook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UploadHook() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackClientStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, ::grpc::ByteBuffer* response) { return this->UploadHook(context, response); }));
    }
    ~WithRawCallbackMethod_UploadHook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadHook(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::File>* /*reader*/, ::FileRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor< ::grpc::ByteBuffer>* UploadHook(
      ::grpc::CallbackServerContext* /*context*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DownloadLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DownloadLog() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->DownloadLog(context, request); }));
    }
    ~WithRawCallbackMethod_DownloadLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadLog(::grpc::ServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::grpc::ServerWriter< ::File>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* DownloadLog(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Login() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::LoginReq, ::ExitRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::LoginReq, ::ExitRes>* streamer) {
                       return this->StreamedLogin(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::LoginReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLogin(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::LoginReq,::ExitRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Logout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Logout() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Inquiry, ::ExitRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Inquiry, ::ExitRes>* streamer) {
                       return this->StreamedLogout(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Logout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Logout(::grpc::ServerContext* /*context*/, const ::Inquiry* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLogout(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Inquiry,::ExitRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateQueue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateQueue() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::QueueReq, ::ExitRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::QueueReq, ::ExitRes>* streamer) {
                       return this->StreamedCreateQueue(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateQueue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateQueue(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateQueue(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::QueueReq,::ExitRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteQueue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteQueue() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::QueueReq, ::ExitRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::QueueReq, ::ExitRes>* streamer) {
                       return this->StreamedDeleteQueue(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteQueue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteQueue(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteQueue(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::QueueReq,::ExitRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListQueue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListQueue() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Inquiry, ::ListQueueRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Inquiry, ::ListQueueRes>* streamer) {
                       return this->StreamedListQueue(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListQueue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListQueue(::grpc::ServerContext* /*context*/, const ::Inquiry* /*request*/, ::ListQueueRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListQueue(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Inquiry,::ListQueueRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddTask() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::AddTaskReq, ::ExitRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::AddTaskReq, ::ExitRes>* streamer) {
                       return this->StreamedAddTask(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AddTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddTask(::grpc::ServerContext* /*context*/, const ::AddTaskReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddTask(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AddTaskReq,::ExitRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteTask() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::TaskIDReq, ::ExitRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::TaskIDReq, ::ExitRes>* streamer) {
                       return this->StreamedDeleteTask(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteTask(::grpc::ServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteTask(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::TaskIDReq,::ExitRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListTask() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::QueueReq, ::ListTaskRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::QueueReq, ::ListTaskRes>* streamer) {
                       return this->StreamedListTask(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListTask(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ListTaskRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListTask(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::QueueReq,::ListTaskRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TaskState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TaskState() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::TaskIDReq, ::TaskStateRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::TaskIDReq, ::TaskStateRes>* streamer) {
                       return this->StreamedTaskState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TaskState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TaskState(::grpc::ServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::TaskStateRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTaskState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::TaskIDReq,::TaskStateRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CurrentRunning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CurrentRunning() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::QueueReq, ::TaskStateRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::QueueReq, ::TaskStateRes>* streamer) {
                       return this->StreamedCurrentRunning(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CurrentRunning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CurrentRunning(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::TaskStateRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCurrentRunning(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::QueueReq,::TaskStateRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopCurrent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StopCurrent() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::QueueReq, ::ExitRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::QueueReq, ::ExitRes>* streamer) {
                       return this->StreamedStopCurrent(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StopCurrent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopCurrent(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopCurrent(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::QueueReq,::ExitRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StopAll() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::QueueReq, ::ExitRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::QueueReq, ::ExitRes>* streamer) {
                       return this->StreamedStopAll(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StopAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopAll(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ExitRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopAll(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::QueueReq,::ExitRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CurrentTaskOutput : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CurrentTaskOutput() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::QueueReq, ::CurrentTaskOutputRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::QueueReq, ::CurrentTaskOutputRes>* streamer) {
                       return this->StreamedCurrentTaskOutput(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CurrentTaskOutput() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CurrentTaskOutput(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::CurrentTaskOutputRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCurrentTaskOutput(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::QueueReq,::CurrentTaskOutputRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListExitedTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListExitedTask() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::QueueReq, ::ListTaskRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::QueueReq, ::ListTaskRes>* streamer) {
                       return this->StreamedListExitedTask(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListExitedTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListExitedTask(::grpc::ServerContext* /*context*/, const ::QueueReq* /*request*/, ::ListTaskRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListExitedTask(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::QueueReq,::ListTaskRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TaskExitState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TaskExitState() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::TaskIDReq, ::TaskExitStateRes>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::TaskIDReq, ::TaskExitStateRes>* streamer) {
                       return this->StreamedTaskExitState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TaskExitState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TaskExitState(::grpc::ServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::TaskExitStateRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTaskExitState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::TaskIDReq,::TaskExitStateRes>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Login<WithStreamedUnaryMethod_Logout<WithStreamedUnaryMethod_CreateQueue<WithStreamedUnaryMethod_DeleteQueue<WithStreamedUnaryMethod_ListQueue<WithStreamedUnaryMethod_AddTask<WithStreamedUnaryMethod_DeleteTask<WithStreamedUnaryMethod_ListTask<WithStreamedUnaryMethod_TaskState<WithStreamedUnaryMethod_CurrentRunning<WithStreamedUnaryMethod_StopCurrent<WithStreamedUnaryMethod_StopAll<WithStreamedUnaryMethod_CurrentTaskOutput<WithStreamedUnaryMethod_ListExitedTask<WithStreamedUnaryMethod_TaskExitState<Service > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_DownloadLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_DownloadLog() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::TaskIDReq, ::File>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::TaskIDReq, ::File>* streamer) {
                       return this->StreamedDownloadLog(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_DownloadLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DownloadLog(::grpc::ServerContext* /*context*/, const ::TaskIDReq* /*request*/, ::grpc::ServerWriter< ::File>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedDownloadLog(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::TaskIDReq,::File>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_DownloadLog<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_Login<WithStreamedUnaryMethod_Logout<WithStreamedUnaryMethod_CreateQueue<WithStreamedUnaryMethod_DeleteQueue<WithStreamedUnaryMethod_ListQueue<WithStreamedUnaryMethod_AddTask<WithStreamedUnaryMethod_DeleteTask<WithStreamedUnaryMethod_ListTask<WithStreamedUnaryMethod_TaskState<WithStreamedUnaryMethod_CurrentRunning<WithStreamedUnaryMethod_StopCurrent<WithStreamedUnaryMethod_StopAll<WithStreamedUnaryMethod_CurrentTaskOutput<WithStreamedUnaryMethod_ListExitedTask<WithStreamedUnaryMethod_TaskExitState<WithSplitStreamingMethod_DownloadLog<Service > > > > > > > > > > > > > > > > StreamedService;
};


#endif  // GRPC_stq_2eproto__INCLUDED
