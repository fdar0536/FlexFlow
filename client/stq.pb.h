// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: stq.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_stq_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_stq_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_stq_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_stq_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_stq_2eproto;
class AddTaskReq;
struct AddTaskReqDefaultTypeInternal;
extern AddTaskReqDefaultTypeInternal _AddTaskReq_default_instance_;
class CurrentTaskOutputRes;
struct CurrentTaskOutputResDefaultTypeInternal;
extern CurrentTaskOutputResDefaultTypeInternal _CurrentTaskOutputRes_default_instance_;
class ExitRes;
struct ExitResDefaultTypeInternal;
extern ExitResDefaultTypeInternal _ExitRes_default_instance_;
class File;
struct FileDefaultTypeInternal;
extern FileDefaultTypeInternal _File_default_instance_;
class FileRes;
struct FileResDefaultTypeInternal;
extern FileResDefaultTypeInternal _FileRes_default_instance_;
class Inquiry;
struct InquiryDefaultTypeInternal;
extern InquiryDefaultTypeInternal _Inquiry_default_instance_;
class ListQueueRes;
struct ListQueueResDefaultTypeInternal;
extern ListQueueResDefaultTypeInternal _ListQueueRes_default_instance_;
class ListTaskRes;
struct ListTaskResDefaultTypeInternal;
extern ListTaskResDefaultTypeInternal _ListTaskRes_default_instance_;
class LoginReq;
struct LoginReqDefaultTypeInternal;
extern LoginReqDefaultTypeInternal _LoginReq_default_instance_;
class QueueReq;
struct QueueReqDefaultTypeInternal;
extern QueueReqDefaultTypeInternal _QueueReq_default_instance_;
class TaskExitStateRes;
struct TaskExitStateResDefaultTypeInternal;
extern TaskExitStateResDefaultTypeInternal _TaskExitStateRes_default_instance_;
class TaskIDReq;
struct TaskIDReqDefaultTypeInternal;
extern TaskIDReqDefaultTypeInternal _TaskIDReq_default_instance_;
class TaskStateRes;
struct TaskStateResDefaultTypeInternal;
extern TaskStateResDefaultTypeInternal _TaskStateRes_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::AddTaskReq* Arena::CreateMaybeMessage<::AddTaskReq>(Arena*);
template<> ::CurrentTaskOutputRes* Arena::CreateMaybeMessage<::CurrentTaskOutputRes>(Arena*);
template<> ::ExitRes* Arena::CreateMaybeMessage<::ExitRes>(Arena*);
template<> ::File* Arena::CreateMaybeMessage<::File>(Arena*);
template<> ::FileRes* Arena::CreateMaybeMessage<::FileRes>(Arena*);
template<> ::Inquiry* Arena::CreateMaybeMessage<::Inquiry>(Arena*);
template<> ::ListQueueRes* Arena::CreateMaybeMessage<::ListQueueRes>(Arena*);
template<> ::ListTaskRes* Arena::CreateMaybeMessage<::ListTaskRes>(Arena*);
template<> ::LoginReq* Arena::CreateMaybeMessage<::LoginReq>(Arena*);
template<> ::QueueReq* Arena::CreateMaybeMessage<::QueueReq>(Arena*);
template<> ::TaskExitStateRes* Arena::CreateMaybeMessage<::TaskExitStateRes>(Arena*);
template<> ::TaskIDReq* Arena::CreateMaybeMessage<::TaskIDReq>(Arena*);
template<> ::TaskStateRes* Arena::CreateMaybeMessage<::TaskStateRes>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum StateCode : int {
  OK = 0,
  FAILED = 1,
  StateCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StateCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StateCode_IsValid(int value);
constexpr StateCode StateCode_MIN = OK;
constexpr StateCode StateCode_MAX = FAILED;
constexpr int StateCode_ARRAYSIZE = StateCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StateCode_descriptor();
template<typename T>
inline const std::string& StateCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StateCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StateCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StateCode_descriptor(), enum_t_value);
}
inline bool StateCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StateCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StateCode>(
    StateCode_descriptor(), name, value);
}
// ===================================================================

class ExitRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ExitRes) */ {
 public:
  inline ExitRes() : ExitRes(nullptr) {}
  ~ExitRes() override;
  explicit constexpr ExitRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExitRes(const ExitRes& from);
  ExitRes(ExitRes&& from) noexcept
    : ExitRes() {
    *this = ::std::move(from);
  }

  inline ExitRes& operator=(const ExitRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExitRes& operator=(ExitRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExitRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExitRes* internal_default_instance() {
    return reinterpret_cast<const ExitRes*>(
               &_ExitRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ExitRes& a, ExitRes& b) {
    a.Swap(&b);
  }
  inline void Swap(ExitRes* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExitRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExitRes* New() const final {
    return new ExitRes();
  }

  ExitRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExitRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExitRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExitRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExitRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ExitRes";
  }
  protected:
  explicit ExitRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 2,
    kStateCodeFieldNumber = 1,
  };
  // string reason = 2;
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_MUST_USE_RESULT std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // .StateCode stateCode = 1;
  void clear_statecode();
  ::StateCode statecode() const;
  void set_statecode(::StateCode value);
  private:
  ::StateCode _internal_statecode() const;
  void _internal_set_statecode(::StateCode value);
  public:

  // @@protoc_insertion_point(class_scope:ExitRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  int statecode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stq_2eproto;
};
// -------------------------------------------------------------------

class Inquiry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Inquiry) */ {
 public:
  inline Inquiry() : Inquiry(nullptr) {}
  ~Inquiry() override;
  explicit constexpr Inquiry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Inquiry(const Inquiry& from);
  Inquiry(Inquiry&& from) noexcept
    : Inquiry() {
    *this = ::std::move(from);
  }

  inline Inquiry& operator=(const Inquiry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Inquiry& operator=(Inquiry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Inquiry& default_instance() {
    return *internal_default_instance();
  }
  static inline const Inquiry* internal_default_instance() {
    return reinterpret_cast<const Inquiry*>(
               &_Inquiry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Inquiry& a, Inquiry& b) {
    a.Swap(&b);
  }
  inline void Swap(Inquiry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Inquiry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Inquiry* New() const final {
    return new Inquiry();
  }

  Inquiry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Inquiry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Inquiry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Inquiry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Inquiry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Inquiry";
  }
  protected:
  explicit Inquiry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_MUST_USE_RESULT std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // @@protoc_insertion_point(class_scope:Inquiry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stq_2eproto;
};
// -------------------------------------------------------------------

class LoginReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LoginReq) */ {
 public:
  inline LoginReq() : LoginReq(nullptr) {}
  ~LoginReq() override;
  explicit constexpr LoginReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginReq(const LoginReq& from);
  LoginReq(LoginReq&& from) noexcept
    : LoginReq() {
    *this = ::std::move(from);
  }

  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginReq& operator=(LoginReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginReq* internal_default_instance() {
    return reinterpret_cast<const LoginReq*>(
               &_LoginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LoginReq& a, LoginReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoginReq* New() const final {
    return new LoginReq();
  }

  LoginReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LoginReq";
  }
  protected:
  explicit LoginReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 1,
    kPassWordFieldNumber = 2,
    kOtpFieldNumber = 3,
  };
  // string userName = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_MUST_USE_RESULT std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string passWord = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_MUST_USE_RESULT std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string otp = 3;
  void clear_otp();
  const std::string& otp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_otp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_otp();
  PROTOBUF_MUST_USE_RESULT std::string* release_otp();
  void set_allocated_otp(std::string* otp);
  private:
  const std::string& _internal_otp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_otp(const std::string& value);
  std::string* _internal_mutable_otp();
  public:

  // @@protoc_insertion_point(class_scope:LoginReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr otp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stq_2eproto;
};
// -------------------------------------------------------------------

class QueueReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:QueueReq) */ {
 public:
  inline QueueReq() : QueueReq(nullptr) {}
  ~QueueReq() override;
  explicit constexpr QueueReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueueReq(const QueueReq& from);
  QueueReq(QueueReq&& from) noexcept
    : QueueReq() {
    *this = ::std::move(from);
  }

  inline QueueReq& operator=(const QueueReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueueReq& operator=(QueueReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueueReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueueReq* internal_default_instance() {
    return reinterpret_cast<const QueueReq*>(
               &_QueueReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(QueueReq& a, QueueReq& b) {
    a.Swap(&b);
  }
  inline void Swap(QueueReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueueReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QueueReq* New() const final {
    return new QueueReq();
  }

  QueueReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QueueReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueueReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueueReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueueReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "QueueReq";
  }
  protected:
  explicit QueueReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_MUST_USE_RESULT std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:QueueReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stq_2eproto;
};
// -------------------------------------------------------------------

class ListQueueRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ListQueueRes) */ {
 public:
  inline ListQueueRes() : ListQueueRes(nullptr) {}
  ~ListQueueRes() override;
  explicit constexpr ListQueueRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListQueueRes(const ListQueueRes& from);
  ListQueueRes(ListQueueRes&& from) noexcept
    : ListQueueRes() {
    *this = ::std::move(from);
  }

  inline ListQueueRes& operator=(const ListQueueRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListQueueRes& operator=(ListQueueRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListQueueRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListQueueRes* internal_default_instance() {
    return reinterpret_cast<const ListQueueRes*>(
               &_ListQueueRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ListQueueRes& a, ListQueueRes& b) {
    a.Swap(&b);
  }
  inline void Swap(ListQueueRes* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListQueueRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListQueueRes* New() const final {
    return new ListQueueRes();
  }

  ListQueueRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListQueueRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListQueueRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListQueueRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListQueueRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ListQueueRes";
  }
  protected:
  explicit ListQueueRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 2,
    kStateCodeFieldNumber = 1,
  };
  // repeated string list = 2;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  const std::string& list(int index) const;
  std::string* mutable_list(int index);
  void set_list(int index, const std::string& value);
  void set_list(int index, std::string&& value);
  void set_list(int index, const char* value);
  void set_list(int index, const char* value, size_t size);
  std::string* add_list();
  void add_list(const std::string& value);
  void add_list(std::string&& value);
  void add_list(const char* value);
  void add_list(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_list();
  private:
  const std::string& _internal_list(int index) const;
  std::string* _internal_add_list();
  public:

  // .StateCode stateCode = 1;
  void clear_statecode();
  ::StateCode statecode() const;
  void set_statecode(::StateCode value);
  private:
  ::StateCode _internal_statecode() const;
  void _internal_set_statecode(::StateCode value);
  public:

  // @@protoc_insertion_point(class_scope:ListQueueRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> list_;
  int statecode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stq_2eproto;
};
// -------------------------------------------------------------------

class AddTaskReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AddTaskReq) */ {
 public:
  inline AddTaskReq() : AddTaskReq(nullptr) {}
  ~AddTaskReq() override;
  explicit constexpr AddTaskReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddTaskReq(const AddTaskReq& from);
  AddTaskReq(AddTaskReq&& from) noexcept
    : AddTaskReq() {
    *this = ::std::move(from);
  }

  inline AddTaskReq& operator=(const AddTaskReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddTaskReq& operator=(AddTaskReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddTaskReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddTaskReq* internal_default_instance() {
    return reinterpret_cast<const AddTaskReq*>(
               &_AddTaskReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AddTaskReq& a, AddTaskReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AddTaskReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddTaskReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddTaskReq* New() const final {
    return new AddTaskReq();
  }

  AddTaskReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddTaskReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddTaskReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddTaskReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddTaskReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AddTaskReq";
  }
  protected:
  explicit AddTaskReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 5,
    kTokenFieldNumber = 1,
    kQueueNameFieldNumber = 2,
    kWorkDirFieldNumber = 3,
    kProgramNameFieldNumber = 4,
  };
  // repeated string args = 5;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  const std::string& args(int index) const;
  std::string* mutable_args(int index);
  void set_args(int index, const std::string& value);
  void set_args(int index, std::string&& value);
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, size_t size);
  std::string* add_args();
  void add_args(const std::string& value);
  void add_args(std::string&& value);
  void add_args(const char* value);
  void add_args(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& args() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_args();
  private:
  const std::string& _internal_args(int index) const;
  std::string* _internal_add_args();
  public:

  // string token = 1;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_MUST_USE_RESULT std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // string queueName = 2;
  void clear_queuename();
  const std::string& queuename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_queuename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_queuename();
  PROTOBUF_MUST_USE_RESULT std::string* release_queuename();
  void set_allocated_queuename(std::string* queuename);
  private:
  const std::string& _internal_queuename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_queuename(const std::string& value);
  std::string* _internal_mutable_queuename();
  public:

  // string workDir = 3;
  void clear_workdir();
  const std::string& workdir() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_workdir(ArgT0&& arg0, ArgT... args);
  std::string* mutable_workdir();
  PROTOBUF_MUST_USE_RESULT std::string* release_workdir();
  void set_allocated_workdir(std::string* workdir);
  private:
  const std::string& _internal_workdir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_workdir(const std::string& value);
  std::string* _internal_mutable_workdir();
  public:

  // string programName = 4;
  void clear_programname();
  const std::string& programname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_programname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_programname();
  PROTOBUF_MUST_USE_RESULT std::string* release_programname();
  void set_allocated_programname(std::string* programname);
  private:
  const std::string& _internal_programname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_programname(const std::string& value);
  std::string* _internal_mutable_programname();
  public:

  // @@protoc_insertion_point(class_scope:AddTaskReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> args_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr queuename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr workdir_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr programname_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stq_2eproto;
};
// -------------------------------------------------------------------

class TaskIDReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TaskIDReq) */ {
 public:
  inline TaskIDReq() : TaskIDReq(nullptr) {}
  ~TaskIDReq() override;
  explicit constexpr TaskIDReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskIDReq(const TaskIDReq& from);
  TaskIDReq(TaskIDReq&& from) noexcept
    : TaskIDReq() {
    *this = ::std::move(from);
  }

  inline TaskIDReq& operator=(const TaskIDReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskIDReq& operator=(TaskIDReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskIDReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskIDReq* internal_default_instance() {
    return reinterpret_cast<const TaskIDReq*>(
               &_TaskIDReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TaskIDReq& a, TaskIDReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskIDReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskIDReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskIDReq* New() const final {
    return new TaskIDReq();
  }

  TaskIDReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskIDReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskIDReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskIDReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskIDReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TaskIDReq";
  }
  protected:
  explicit TaskIDReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kQueueNameFieldNumber = 2,
    kIdFieldNumber = 3,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_MUST_USE_RESULT std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // string queueName = 2;
  void clear_queuename();
  const std::string& queuename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_queuename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_queuename();
  PROTOBUF_MUST_USE_RESULT std::string* release_queuename();
  void set_allocated_queuename(std::string* queuename);
  private:
  const std::string& _internal_queuename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_queuename(const std::string& value);
  std::string* _internal_mutable_queuename();
  public:

  // uint32 id = 3;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:TaskIDReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr queuename_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stq_2eproto;
};
// -------------------------------------------------------------------

class ListTaskRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ListTaskRes) */ {
 public:
  inline ListTaskRes() : ListTaskRes(nullptr) {}
  ~ListTaskRes() override;
  explicit constexpr ListTaskRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListTaskRes(const ListTaskRes& from);
  ListTaskRes(ListTaskRes&& from) noexcept
    : ListTaskRes() {
    *this = ::std::move(from);
  }

  inline ListTaskRes& operator=(const ListTaskRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTaskRes& operator=(ListTaskRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTaskRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTaskRes* internal_default_instance() {
    return reinterpret_cast<const ListTaskRes*>(
               &_ListTaskRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ListTaskRes& a, ListTaskRes& b) {
    a.Swap(&b);
  }
  inline void Swap(ListTaskRes* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTaskRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListTaskRes* New() const final {
    return new ListTaskRes();
  }

  ListTaskRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListTaskRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListTaskRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListTaskRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListTaskRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ListTaskRes";
  }
  protected:
  explicit ListTaskRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 2,
    kStateCodeFieldNumber = 1,
  };
  // repeated uint32 list = 2;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_list(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_list() const;
  void _internal_add_list(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_list();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 list(int index) const;
  void set_list(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_list(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_list();

  // .StateCode stateCode = 1;
  void clear_statecode();
  ::StateCode statecode() const;
  void set_statecode(::StateCode value);
  private:
  ::StateCode _internal_statecode() const;
  void _internal_set_statecode(::StateCode value);
  public:

  // @@protoc_insertion_point(class_scope:ListTaskRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > list_;
  mutable std::atomic<int> _list_cached_byte_size_;
  int statecode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stq_2eproto;
};
// -------------------------------------------------------------------

class TaskStateRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TaskStateRes) */ {
 public:
  inline TaskStateRes() : TaskStateRes(nullptr) {}
  ~TaskStateRes() override;
  explicit constexpr TaskStateRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskStateRes(const TaskStateRes& from);
  TaskStateRes(TaskStateRes&& from) noexcept
    : TaskStateRes() {
    *this = ::std::move(from);
  }

  inline TaskStateRes& operator=(const TaskStateRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskStateRes& operator=(TaskStateRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskStateRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskStateRes* internal_default_instance() {
    return reinterpret_cast<const TaskStateRes*>(
               &_TaskStateRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TaskStateRes& a, TaskStateRes& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskStateRes* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskStateRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskStateRes* New() const final {
    return new TaskStateRes();
  }

  TaskStateRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskStateRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskStateRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskStateRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskStateRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TaskStateRes";
  }
  protected:
  explicit TaskStateRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 4,
    kWorkDirFieldNumber = 2,
    kProgramNameFieldNumber = 3,
    kStateCodeFieldNumber = 1,
  };
  // repeated string args = 4;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  const std::string& args(int index) const;
  std::string* mutable_args(int index);
  void set_args(int index, const std::string& value);
  void set_args(int index, std::string&& value);
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, size_t size);
  std::string* add_args();
  void add_args(const std::string& value);
  void add_args(std::string&& value);
  void add_args(const char* value);
  void add_args(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& args() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_args();
  private:
  const std::string& _internal_args(int index) const;
  std::string* _internal_add_args();
  public:

  // string workDir = 2;
  void clear_workdir();
  const std::string& workdir() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_workdir(ArgT0&& arg0, ArgT... args);
  std::string* mutable_workdir();
  PROTOBUF_MUST_USE_RESULT std::string* release_workdir();
  void set_allocated_workdir(std::string* workdir);
  private:
  const std::string& _internal_workdir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_workdir(const std::string& value);
  std::string* _internal_mutable_workdir();
  public:

  // string programName = 3;
  void clear_programname();
  const std::string& programname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_programname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_programname();
  PROTOBUF_MUST_USE_RESULT std::string* release_programname();
  void set_allocated_programname(std::string* programname);
  private:
  const std::string& _internal_programname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_programname(const std::string& value);
  std::string* _internal_mutable_programname();
  public:

  // .StateCode stateCode = 1;
  void clear_statecode();
  ::StateCode statecode() const;
  void set_statecode(::StateCode value);
  private:
  ::StateCode _internal_statecode() const;
  void _internal_set_statecode(::StateCode value);
  public:

  // @@protoc_insertion_point(class_scope:TaskStateRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> args_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr workdir_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr programname_;
  int statecode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stq_2eproto;
};
// -------------------------------------------------------------------

class CurrentTaskOutputRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CurrentTaskOutputRes) */ {
 public:
  inline CurrentTaskOutputRes() : CurrentTaskOutputRes(nullptr) {}
  ~CurrentTaskOutputRes() override;
  explicit constexpr CurrentTaskOutputRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CurrentTaskOutputRes(const CurrentTaskOutputRes& from);
  CurrentTaskOutputRes(CurrentTaskOutputRes&& from) noexcept
    : CurrentTaskOutputRes() {
    *this = ::std::move(from);
  }

  inline CurrentTaskOutputRes& operator=(const CurrentTaskOutputRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurrentTaskOutputRes& operator=(CurrentTaskOutputRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CurrentTaskOutputRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const CurrentTaskOutputRes* internal_default_instance() {
    return reinterpret_cast<const CurrentTaskOutputRes*>(
               &_CurrentTaskOutputRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CurrentTaskOutputRes& a, CurrentTaskOutputRes& b) {
    a.Swap(&b);
  }
  inline void Swap(CurrentTaskOutputRes* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurrentTaskOutputRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CurrentTaskOutputRes* New() const final {
    return new CurrentTaskOutputRes();
  }

  CurrentTaskOutputRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CurrentTaskOutputRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CurrentTaskOutputRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CurrentTaskOutputRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurrentTaskOutputRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CurrentTaskOutputRes";
  }
  protected:
  explicit CurrentTaskOutputRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutputFieldNumber = 2,
    kStateCodeFieldNumber = 1,
  };
  // string output = 2;
  void clear_output();
  const std::string& output() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_output(ArgT0&& arg0, ArgT... args);
  std::string* mutable_output();
  PROTOBUF_MUST_USE_RESULT std::string* release_output();
  void set_allocated_output(std::string* output);
  private:
  const std::string& _internal_output() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_output(const std::string& value);
  std::string* _internal_mutable_output();
  public:

  // .StateCode stateCode = 1;
  void clear_statecode();
  ::StateCode statecode() const;
  void set_statecode(::StateCode value);
  private:
  ::StateCode _internal_statecode() const;
  void _internal_set_statecode(::StateCode value);
  public:

  // @@protoc_insertion_point(class_scope:CurrentTaskOutputRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr output_;
  int statecode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stq_2eproto;
};
// -------------------------------------------------------------------

class TaskExitStateRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TaskExitStateRes) */ {
 public:
  inline TaskExitStateRes() : TaskExitStateRes(nullptr) {}
  ~TaskExitStateRes() override;
  explicit constexpr TaskExitStateRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskExitStateRes(const TaskExitStateRes& from);
  TaskExitStateRes(TaskExitStateRes&& from) noexcept
    : TaskExitStateRes() {
    *this = ::std::move(from);
  }

  inline TaskExitStateRes& operator=(const TaskExitStateRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskExitStateRes& operator=(TaskExitStateRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskExitStateRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskExitStateRes* internal_default_instance() {
    return reinterpret_cast<const TaskExitStateRes*>(
               &_TaskExitStateRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TaskExitStateRes& a, TaskExitStateRes& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskExitStateRes* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskExitStateRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskExitStateRes* New() const final {
    return new TaskExitStateRes();
  }

  TaskExitStateRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskExitStateRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskExitStateRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskExitStateRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskExitStateRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TaskExitStateRes";
  }
  protected:
  explicit TaskExitStateRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 4,
    kWorkDirFieldNumber = 2,
    kProgramNameFieldNumber = 3,
    kStateCodeFieldNumber = 1,
    kExitCodeFieldNumber = 5,
  };
  // repeated string args = 4;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  const std::string& args(int index) const;
  std::string* mutable_args(int index);
  void set_args(int index, const std::string& value);
  void set_args(int index, std::string&& value);
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, size_t size);
  std::string* add_args();
  void add_args(const std::string& value);
  void add_args(std::string&& value);
  void add_args(const char* value);
  void add_args(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& args() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_args();
  private:
  const std::string& _internal_args(int index) const;
  std::string* _internal_add_args();
  public:

  // string workDir = 2;
  void clear_workdir();
  const std::string& workdir() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_workdir(ArgT0&& arg0, ArgT... args);
  std::string* mutable_workdir();
  PROTOBUF_MUST_USE_RESULT std::string* release_workdir();
  void set_allocated_workdir(std::string* workdir);
  private:
  const std::string& _internal_workdir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_workdir(const std::string& value);
  std::string* _internal_mutable_workdir();
  public:

  // string programName = 3;
  void clear_programname();
  const std::string& programname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_programname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_programname();
  PROTOBUF_MUST_USE_RESULT std::string* release_programname();
  void set_allocated_programname(std::string* programname);
  private:
  const std::string& _internal_programname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_programname(const std::string& value);
  std::string* _internal_mutable_programname();
  public:

  // .StateCode stateCode = 1;
  void clear_statecode();
  ::StateCode statecode() const;
  void set_statecode(::StateCode value);
  private:
  ::StateCode _internal_statecode() const;
  void _internal_set_statecode(::StateCode value);
  public:

  // int32 exitCode = 5;
  void clear_exitcode();
  ::PROTOBUF_NAMESPACE_ID::int32 exitcode() const;
  void set_exitcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_exitcode() const;
  void _internal_set_exitcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:TaskExitStateRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> args_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr workdir_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr programname_;
  int statecode_;
  ::PROTOBUF_NAMESPACE_ID::int32 exitcode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stq_2eproto;
};
// -------------------------------------------------------------------

class File final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:File) */ {
 public:
  inline File() : File(nullptr) {}
  ~File() override;
  explicit constexpr File(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  File(const File& from);
  File(File&& from) noexcept
    : File() {
    *this = ::std::move(from);
  }

  inline File& operator=(const File& from) {
    CopyFrom(from);
    return *this;
  }
  inline File& operator=(File&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const File& default_instance() {
    return *internal_default_instance();
  }
  static inline const File* internal_default_instance() {
    return reinterpret_cast<const File*>(
               &_File_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(File& a, File& b) {
    a.Swap(&b);
  }
  inline void Swap(File* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(File* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline File* New() const final {
    return new File();
  }

  File* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<File>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const File& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const File& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(File* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "File";
  }
  protected:
  explicit File(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 1,
  };
  // bytes content = 1;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_MUST_USE_RESULT std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // @@protoc_insertion_point(class_scope:File)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stq_2eproto;
};
// -------------------------------------------------------------------

class FileRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FileRes) */ {
 public:
  inline FileRes() : FileRes(nullptr) {}
  ~FileRes() override;
  explicit constexpr FileRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileRes(const FileRes& from);
  FileRes(FileRes&& from) noexcept
    : FileRes() {
    *this = ::std::move(from);
  }

  inline FileRes& operator=(const FileRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileRes& operator=(FileRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileRes* internal_default_instance() {
    return reinterpret_cast<const FileRes*>(
               &_FileRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(FileRes& a, FileRes& b) {
    a.Swap(&b);
  }
  inline void Swap(FileRes* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileRes* New() const final {
    return new FileRes();
  }

  FileRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FileRes";
  }
  protected:
  explicit FileRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 2,
    kStateCodeFieldNumber = 1,
  };
  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_MUST_USE_RESULT std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .StateCode stateCode = 1;
  void clear_statecode();
  ::StateCode statecode() const;
  void set_statecode(::StateCode value);
  private:
  ::StateCode _internal_statecode() const;
  void _internal_set_statecode(::StateCode value);
  public:

  // @@protoc_insertion_point(class_scope:FileRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  int statecode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stq_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ExitRes

// .StateCode stateCode = 1;
inline void ExitRes::clear_statecode() {
  statecode_ = 0;
}
inline ::StateCode ExitRes::_internal_statecode() const {
  return static_cast< ::StateCode >(statecode_);
}
inline ::StateCode ExitRes::statecode() const {
  // @@protoc_insertion_point(field_get:ExitRes.stateCode)
  return _internal_statecode();
}
inline void ExitRes::_internal_set_statecode(::StateCode value) {
  
  statecode_ = value;
}
inline void ExitRes::set_statecode(::StateCode value) {
  _internal_set_statecode(value);
  // @@protoc_insertion_point(field_set:ExitRes.stateCode)
}

// string reason = 2;
inline void ExitRes::clear_reason() {
  reason_.ClearToEmpty();
}
inline const std::string& ExitRes::reason() const {
  // @@protoc_insertion_point(field_get:ExitRes.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExitRes::set_reason(ArgT0&& arg0, ArgT... args) {
 
 reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ExitRes.reason)
}
inline std::string* ExitRes::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:ExitRes.reason)
  return _s;
}
inline const std::string& ExitRes::_internal_reason() const {
  return reason_.Get();
}
inline void ExitRes::_internal_set_reason(const std::string& value) {
  
  reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExitRes::_internal_mutable_reason() {
  
  return reason_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExitRes::release_reason() {
  // @@protoc_insertion_point(field_release:ExitRes.reason)
  return reason_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExitRes::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  reason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ExitRes.reason)
}

// -------------------------------------------------------------------

// Inquiry

// string token = 1;
inline void Inquiry::clear_token() {
  token_.ClearToEmpty();
}
inline const std::string& Inquiry::token() const {
  // @@protoc_insertion_point(field_get:Inquiry.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Inquiry::set_token(ArgT0&& arg0, ArgT... args) {
 
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Inquiry.token)
}
inline std::string* Inquiry::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:Inquiry.token)
  return _s;
}
inline const std::string& Inquiry::_internal_token() const {
  return token_.Get();
}
inline void Inquiry::_internal_set_token(const std::string& value) {
  
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Inquiry::_internal_mutable_token() {
  
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Inquiry::release_token() {
  // @@protoc_insertion_point(field_release:Inquiry.token)
  return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Inquiry::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Inquiry.token)
}

// -------------------------------------------------------------------

// LoginReq

// string userName = 1;
inline void LoginReq::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& LoginReq::username() const {
  // @@protoc_insertion_point(field_get:LoginReq.userName)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginReq::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LoginReq.userName)
}
inline std::string* LoginReq::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:LoginReq.userName)
  return _s;
}
inline const std::string& LoginReq::_internal_username() const {
  return username_.Get();
}
inline void LoginReq::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginReq::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginReq::release_username() {
  // @@protoc_insertion_point(field_release:LoginReq.userName)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginReq::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:LoginReq.userName)
}

// string passWord = 2;
inline void LoginReq::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& LoginReq::password() const {
  // @@protoc_insertion_point(field_get:LoginReq.passWord)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginReq::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LoginReq.passWord)
}
inline std::string* LoginReq::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:LoginReq.passWord)
  return _s;
}
inline const std::string& LoginReq::_internal_password() const {
  return password_.Get();
}
inline void LoginReq::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginReq::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginReq::release_password() {
  // @@protoc_insertion_point(field_release:LoginReq.passWord)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:LoginReq.passWord)
}

// string otp = 3;
inline void LoginReq::clear_otp() {
  otp_.ClearToEmpty();
}
inline const std::string& LoginReq::otp() const {
  // @@protoc_insertion_point(field_get:LoginReq.otp)
  return _internal_otp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginReq::set_otp(ArgT0&& arg0, ArgT... args) {
 
 otp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LoginReq.otp)
}
inline std::string* LoginReq::mutable_otp() {
  std::string* _s = _internal_mutable_otp();
  // @@protoc_insertion_point(field_mutable:LoginReq.otp)
  return _s;
}
inline const std::string& LoginReq::_internal_otp() const {
  return otp_.Get();
}
inline void LoginReq::_internal_set_otp(const std::string& value) {
  
  otp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginReq::_internal_mutable_otp() {
  
  return otp_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginReq::release_otp() {
  // @@protoc_insertion_point(field_release:LoginReq.otp)
  return otp_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginReq::set_allocated_otp(std::string* otp) {
  if (otp != nullptr) {
    
  } else {
    
  }
  otp_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), otp,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:LoginReq.otp)
}

// -------------------------------------------------------------------

// QueueReq

// string token = 1;
inline void QueueReq::clear_token() {
  token_.ClearToEmpty();
}
inline const std::string& QueueReq::token() const {
  // @@protoc_insertion_point(field_get:QueueReq.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueueReq::set_token(ArgT0&& arg0, ArgT... args) {
 
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:QueueReq.token)
}
inline std::string* QueueReq::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:QueueReq.token)
  return _s;
}
inline const std::string& QueueReq::_internal_token() const {
  return token_.Get();
}
inline void QueueReq::_internal_set_token(const std::string& value) {
  
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueueReq::_internal_mutable_token() {
  
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueueReq::release_token() {
  // @@protoc_insertion_point(field_release:QueueReq.token)
  return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueueReq::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:QueueReq.token)
}

// string name = 2;
inline void QueueReq::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& QueueReq::name() const {
  // @@protoc_insertion_point(field_get:QueueReq.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueueReq::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:QueueReq.name)
}
inline std::string* QueueReq::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:QueueReq.name)
  return _s;
}
inline const std::string& QueueReq::_internal_name() const {
  return name_.Get();
}
inline void QueueReq::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueueReq::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueueReq::release_name() {
  // @@protoc_insertion_point(field_release:QueueReq.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueueReq::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:QueueReq.name)
}

// -------------------------------------------------------------------

// ListQueueRes

// .StateCode stateCode = 1;
inline void ListQueueRes::clear_statecode() {
  statecode_ = 0;
}
inline ::StateCode ListQueueRes::_internal_statecode() const {
  return static_cast< ::StateCode >(statecode_);
}
inline ::StateCode ListQueueRes::statecode() const {
  // @@protoc_insertion_point(field_get:ListQueueRes.stateCode)
  return _internal_statecode();
}
inline void ListQueueRes::_internal_set_statecode(::StateCode value) {
  
  statecode_ = value;
}
inline void ListQueueRes::set_statecode(::StateCode value) {
  _internal_set_statecode(value);
  // @@protoc_insertion_point(field_set:ListQueueRes.stateCode)
}

// repeated string list = 2;
inline int ListQueueRes::_internal_list_size() const {
  return list_.size();
}
inline int ListQueueRes::list_size() const {
  return _internal_list_size();
}
inline void ListQueueRes::clear_list() {
  list_.Clear();
}
inline std::string* ListQueueRes::add_list() {
  std::string* _s = _internal_add_list();
  // @@protoc_insertion_point(field_add_mutable:ListQueueRes.list)
  return _s;
}
inline const std::string& ListQueueRes::_internal_list(int index) const {
  return list_.Get(index);
}
inline const std::string& ListQueueRes::list(int index) const {
  // @@protoc_insertion_point(field_get:ListQueueRes.list)
  return _internal_list(index);
}
inline std::string* ListQueueRes::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:ListQueueRes.list)
  return list_.Mutable(index);
}
inline void ListQueueRes::set_list(int index, const std::string& value) {
  list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ListQueueRes.list)
}
inline void ListQueueRes::set_list(int index, std::string&& value) {
  list_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ListQueueRes.list)
}
inline void ListQueueRes::set_list(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ListQueueRes.list)
}
inline void ListQueueRes::set_list(int index, const char* value, size_t size) {
  list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ListQueueRes.list)
}
inline std::string* ListQueueRes::_internal_add_list() {
  return list_.Add();
}
inline void ListQueueRes::add_list(const std::string& value) {
  list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ListQueueRes.list)
}
inline void ListQueueRes::add_list(std::string&& value) {
  list_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ListQueueRes.list)
}
inline void ListQueueRes::add_list(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ListQueueRes.list)
}
inline void ListQueueRes::add_list(const char* value, size_t size) {
  list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ListQueueRes.list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListQueueRes::list() const {
  // @@protoc_insertion_point(field_list:ListQueueRes.list)
  return list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListQueueRes::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:ListQueueRes.list)
  return &list_;
}

// -------------------------------------------------------------------

// AddTaskReq

// string token = 1;
inline void AddTaskReq::clear_token() {
  token_.ClearToEmpty();
}
inline const std::string& AddTaskReq::token() const {
  // @@protoc_insertion_point(field_get:AddTaskReq.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddTaskReq::set_token(ArgT0&& arg0, ArgT... args) {
 
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AddTaskReq.token)
}
inline std::string* AddTaskReq::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:AddTaskReq.token)
  return _s;
}
inline const std::string& AddTaskReq::_internal_token() const {
  return token_.Get();
}
inline void AddTaskReq::_internal_set_token(const std::string& value) {
  
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AddTaskReq::_internal_mutable_token() {
  
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AddTaskReq::release_token() {
  // @@protoc_insertion_point(field_release:AddTaskReq.token)
  return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AddTaskReq::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:AddTaskReq.token)
}

// string queueName = 2;
inline void AddTaskReq::clear_queuename() {
  queuename_.ClearToEmpty();
}
inline const std::string& AddTaskReq::queuename() const {
  // @@protoc_insertion_point(field_get:AddTaskReq.queueName)
  return _internal_queuename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddTaskReq::set_queuename(ArgT0&& arg0, ArgT... args) {
 
 queuename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AddTaskReq.queueName)
}
inline std::string* AddTaskReq::mutable_queuename() {
  std::string* _s = _internal_mutable_queuename();
  // @@protoc_insertion_point(field_mutable:AddTaskReq.queueName)
  return _s;
}
inline const std::string& AddTaskReq::_internal_queuename() const {
  return queuename_.Get();
}
inline void AddTaskReq::_internal_set_queuename(const std::string& value) {
  
  queuename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AddTaskReq::_internal_mutable_queuename() {
  
  return queuename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AddTaskReq::release_queuename() {
  // @@protoc_insertion_point(field_release:AddTaskReq.queueName)
  return queuename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AddTaskReq::set_allocated_queuename(std::string* queuename) {
  if (queuename != nullptr) {
    
  } else {
    
  }
  queuename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), queuename,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:AddTaskReq.queueName)
}

// string workDir = 3;
inline void AddTaskReq::clear_workdir() {
  workdir_.ClearToEmpty();
}
inline const std::string& AddTaskReq::workdir() const {
  // @@protoc_insertion_point(field_get:AddTaskReq.workDir)
  return _internal_workdir();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddTaskReq::set_workdir(ArgT0&& arg0, ArgT... args) {
 
 workdir_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AddTaskReq.workDir)
}
inline std::string* AddTaskReq::mutable_workdir() {
  std::string* _s = _internal_mutable_workdir();
  // @@protoc_insertion_point(field_mutable:AddTaskReq.workDir)
  return _s;
}
inline const std::string& AddTaskReq::_internal_workdir() const {
  return workdir_.Get();
}
inline void AddTaskReq::_internal_set_workdir(const std::string& value) {
  
  workdir_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AddTaskReq::_internal_mutable_workdir() {
  
  return workdir_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AddTaskReq::release_workdir() {
  // @@protoc_insertion_point(field_release:AddTaskReq.workDir)
  return workdir_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AddTaskReq::set_allocated_workdir(std::string* workdir) {
  if (workdir != nullptr) {
    
  } else {
    
  }
  workdir_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), workdir,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:AddTaskReq.workDir)
}

// string programName = 4;
inline void AddTaskReq::clear_programname() {
  programname_.ClearToEmpty();
}
inline const std::string& AddTaskReq::programname() const {
  // @@protoc_insertion_point(field_get:AddTaskReq.programName)
  return _internal_programname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddTaskReq::set_programname(ArgT0&& arg0, ArgT... args) {
 
 programname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AddTaskReq.programName)
}
inline std::string* AddTaskReq::mutable_programname() {
  std::string* _s = _internal_mutable_programname();
  // @@protoc_insertion_point(field_mutable:AddTaskReq.programName)
  return _s;
}
inline const std::string& AddTaskReq::_internal_programname() const {
  return programname_.Get();
}
inline void AddTaskReq::_internal_set_programname(const std::string& value) {
  
  programname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AddTaskReq::_internal_mutable_programname() {
  
  return programname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AddTaskReq::release_programname() {
  // @@protoc_insertion_point(field_release:AddTaskReq.programName)
  return programname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AddTaskReq::set_allocated_programname(std::string* programname) {
  if (programname != nullptr) {
    
  } else {
    
  }
  programname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), programname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:AddTaskReq.programName)
}

// repeated string args = 5;
inline int AddTaskReq::_internal_args_size() const {
  return args_.size();
}
inline int AddTaskReq::args_size() const {
  return _internal_args_size();
}
inline void AddTaskReq::clear_args() {
  args_.Clear();
}
inline std::string* AddTaskReq::add_args() {
  std::string* _s = _internal_add_args();
  // @@protoc_insertion_point(field_add_mutable:AddTaskReq.args)
  return _s;
}
inline const std::string& AddTaskReq::_internal_args(int index) const {
  return args_.Get(index);
}
inline const std::string& AddTaskReq::args(int index) const {
  // @@protoc_insertion_point(field_get:AddTaskReq.args)
  return _internal_args(index);
}
inline std::string* AddTaskReq::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:AddTaskReq.args)
  return args_.Mutable(index);
}
inline void AddTaskReq::set_args(int index, const std::string& value) {
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:AddTaskReq.args)
}
inline void AddTaskReq::set_args(int index, std::string&& value) {
  args_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:AddTaskReq.args)
}
inline void AddTaskReq::set_args(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:AddTaskReq.args)
}
inline void AddTaskReq::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AddTaskReq.args)
}
inline std::string* AddTaskReq::_internal_add_args() {
  return args_.Add();
}
inline void AddTaskReq::add_args(const std::string& value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:AddTaskReq.args)
}
inline void AddTaskReq::add_args(std::string&& value) {
  args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:AddTaskReq.args)
}
inline void AddTaskReq::add_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:AddTaskReq.args)
}
inline void AddTaskReq::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:AddTaskReq.args)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AddTaskReq::args() const {
  // @@protoc_insertion_point(field_list:AddTaskReq.args)
  return args_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AddTaskReq::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:AddTaskReq.args)
  return &args_;
}

// -------------------------------------------------------------------

// TaskIDReq

// string token = 1;
inline void TaskIDReq::clear_token() {
  token_.ClearToEmpty();
}
inline const std::string& TaskIDReq::token() const {
  // @@protoc_insertion_point(field_get:TaskIDReq.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskIDReq::set_token(ArgT0&& arg0, ArgT... args) {
 
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TaskIDReq.token)
}
inline std::string* TaskIDReq::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:TaskIDReq.token)
  return _s;
}
inline const std::string& TaskIDReq::_internal_token() const {
  return token_.Get();
}
inline void TaskIDReq::_internal_set_token(const std::string& value) {
  
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskIDReq::_internal_mutable_token() {
  
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskIDReq::release_token() {
  // @@protoc_insertion_point(field_release:TaskIDReq.token)
  return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskIDReq::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:TaskIDReq.token)
}

// string queueName = 2;
inline void TaskIDReq::clear_queuename() {
  queuename_.ClearToEmpty();
}
inline const std::string& TaskIDReq::queuename() const {
  // @@protoc_insertion_point(field_get:TaskIDReq.queueName)
  return _internal_queuename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskIDReq::set_queuename(ArgT0&& arg0, ArgT... args) {
 
 queuename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TaskIDReq.queueName)
}
inline std::string* TaskIDReq::mutable_queuename() {
  std::string* _s = _internal_mutable_queuename();
  // @@protoc_insertion_point(field_mutable:TaskIDReq.queueName)
  return _s;
}
inline const std::string& TaskIDReq::_internal_queuename() const {
  return queuename_.Get();
}
inline void TaskIDReq::_internal_set_queuename(const std::string& value) {
  
  queuename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskIDReq::_internal_mutable_queuename() {
  
  return queuename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskIDReq::release_queuename() {
  // @@protoc_insertion_point(field_release:TaskIDReq.queueName)
  return queuename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskIDReq::set_allocated_queuename(std::string* queuename) {
  if (queuename != nullptr) {
    
  } else {
    
  }
  queuename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), queuename,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:TaskIDReq.queueName)
}

// uint32 id = 3;
inline void TaskIDReq::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TaskIDReq::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TaskIDReq::id() const {
  // @@protoc_insertion_point(field_get:TaskIDReq.id)
  return _internal_id();
}
inline void TaskIDReq::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void TaskIDReq::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:TaskIDReq.id)
}

// -------------------------------------------------------------------

// ListTaskRes

// .StateCode stateCode = 1;
inline void ListTaskRes::clear_statecode() {
  statecode_ = 0;
}
inline ::StateCode ListTaskRes::_internal_statecode() const {
  return static_cast< ::StateCode >(statecode_);
}
inline ::StateCode ListTaskRes::statecode() const {
  // @@protoc_insertion_point(field_get:ListTaskRes.stateCode)
  return _internal_statecode();
}
inline void ListTaskRes::_internal_set_statecode(::StateCode value) {
  
  statecode_ = value;
}
inline void ListTaskRes::set_statecode(::StateCode value) {
  _internal_set_statecode(value);
  // @@protoc_insertion_point(field_set:ListTaskRes.stateCode)
}

// repeated uint32 list = 2;
inline int ListTaskRes::_internal_list_size() const {
  return list_.size();
}
inline int ListTaskRes::list_size() const {
  return _internal_list_size();
}
inline void ListTaskRes::clear_list() {
  list_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListTaskRes::_internal_list(int index) const {
  return list_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ListTaskRes::list(int index) const {
  // @@protoc_insertion_point(field_get:ListTaskRes.list)
  return _internal_list(index);
}
inline void ListTaskRes::set_list(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  list_.Set(index, value);
  // @@protoc_insertion_point(field_set:ListTaskRes.list)
}
inline void ListTaskRes::_internal_add_list(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  list_.Add(value);
}
inline void ListTaskRes::add_list(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_list(value);
  // @@protoc_insertion_point(field_add:ListTaskRes.list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
ListTaskRes::_internal_list() const {
  return list_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
ListTaskRes::list() const {
  // @@protoc_insertion_point(field_list:ListTaskRes.list)
  return _internal_list();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
ListTaskRes::_internal_mutable_list() {
  return &list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
ListTaskRes::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:ListTaskRes.list)
  return _internal_mutable_list();
}

// -------------------------------------------------------------------

// TaskStateRes

// .StateCode stateCode = 1;
inline void TaskStateRes::clear_statecode() {
  statecode_ = 0;
}
inline ::StateCode TaskStateRes::_internal_statecode() const {
  return static_cast< ::StateCode >(statecode_);
}
inline ::StateCode TaskStateRes::statecode() const {
  // @@protoc_insertion_point(field_get:TaskStateRes.stateCode)
  return _internal_statecode();
}
inline void TaskStateRes::_internal_set_statecode(::StateCode value) {
  
  statecode_ = value;
}
inline void TaskStateRes::set_statecode(::StateCode value) {
  _internal_set_statecode(value);
  // @@protoc_insertion_point(field_set:TaskStateRes.stateCode)
}

// string workDir = 2;
inline void TaskStateRes::clear_workdir() {
  workdir_.ClearToEmpty();
}
inline const std::string& TaskStateRes::workdir() const {
  // @@protoc_insertion_point(field_get:TaskStateRes.workDir)
  return _internal_workdir();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskStateRes::set_workdir(ArgT0&& arg0, ArgT... args) {
 
 workdir_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TaskStateRes.workDir)
}
inline std::string* TaskStateRes::mutable_workdir() {
  std::string* _s = _internal_mutable_workdir();
  // @@protoc_insertion_point(field_mutable:TaskStateRes.workDir)
  return _s;
}
inline const std::string& TaskStateRes::_internal_workdir() const {
  return workdir_.Get();
}
inline void TaskStateRes::_internal_set_workdir(const std::string& value) {
  
  workdir_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskStateRes::_internal_mutable_workdir() {
  
  return workdir_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskStateRes::release_workdir() {
  // @@protoc_insertion_point(field_release:TaskStateRes.workDir)
  return workdir_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskStateRes::set_allocated_workdir(std::string* workdir) {
  if (workdir != nullptr) {
    
  } else {
    
  }
  workdir_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), workdir,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:TaskStateRes.workDir)
}

// string programName = 3;
inline void TaskStateRes::clear_programname() {
  programname_.ClearToEmpty();
}
inline const std::string& TaskStateRes::programname() const {
  // @@protoc_insertion_point(field_get:TaskStateRes.programName)
  return _internal_programname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskStateRes::set_programname(ArgT0&& arg0, ArgT... args) {
 
 programname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TaskStateRes.programName)
}
inline std::string* TaskStateRes::mutable_programname() {
  std::string* _s = _internal_mutable_programname();
  // @@protoc_insertion_point(field_mutable:TaskStateRes.programName)
  return _s;
}
inline const std::string& TaskStateRes::_internal_programname() const {
  return programname_.Get();
}
inline void TaskStateRes::_internal_set_programname(const std::string& value) {
  
  programname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskStateRes::_internal_mutable_programname() {
  
  return programname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskStateRes::release_programname() {
  // @@protoc_insertion_point(field_release:TaskStateRes.programName)
  return programname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskStateRes::set_allocated_programname(std::string* programname) {
  if (programname != nullptr) {
    
  } else {
    
  }
  programname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), programname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:TaskStateRes.programName)
}

// repeated string args = 4;
inline int TaskStateRes::_internal_args_size() const {
  return args_.size();
}
inline int TaskStateRes::args_size() const {
  return _internal_args_size();
}
inline void TaskStateRes::clear_args() {
  args_.Clear();
}
inline std::string* TaskStateRes::add_args() {
  std::string* _s = _internal_add_args();
  // @@protoc_insertion_point(field_add_mutable:TaskStateRes.args)
  return _s;
}
inline const std::string& TaskStateRes::_internal_args(int index) const {
  return args_.Get(index);
}
inline const std::string& TaskStateRes::args(int index) const {
  // @@protoc_insertion_point(field_get:TaskStateRes.args)
  return _internal_args(index);
}
inline std::string* TaskStateRes::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:TaskStateRes.args)
  return args_.Mutable(index);
}
inline void TaskStateRes::set_args(int index, const std::string& value) {
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:TaskStateRes.args)
}
inline void TaskStateRes::set_args(int index, std::string&& value) {
  args_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:TaskStateRes.args)
}
inline void TaskStateRes::set_args(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TaskStateRes.args)
}
inline void TaskStateRes::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TaskStateRes.args)
}
inline std::string* TaskStateRes::_internal_add_args() {
  return args_.Add();
}
inline void TaskStateRes::add_args(const std::string& value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TaskStateRes.args)
}
inline void TaskStateRes::add_args(std::string&& value) {
  args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TaskStateRes.args)
}
inline void TaskStateRes::add_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TaskStateRes.args)
}
inline void TaskStateRes::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TaskStateRes.args)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TaskStateRes::args() const {
  // @@protoc_insertion_point(field_list:TaskStateRes.args)
  return args_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TaskStateRes::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:TaskStateRes.args)
  return &args_;
}

// -------------------------------------------------------------------

// CurrentTaskOutputRes

// .StateCode stateCode = 1;
inline void CurrentTaskOutputRes::clear_statecode() {
  statecode_ = 0;
}
inline ::StateCode CurrentTaskOutputRes::_internal_statecode() const {
  return static_cast< ::StateCode >(statecode_);
}
inline ::StateCode CurrentTaskOutputRes::statecode() const {
  // @@protoc_insertion_point(field_get:CurrentTaskOutputRes.stateCode)
  return _internal_statecode();
}
inline void CurrentTaskOutputRes::_internal_set_statecode(::StateCode value) {
  
  statecode_ = value;
}
inline void CurrentTaskOutputRes::set_statecode(::StateCode value) {
  _internal_set_statecode(value);
  // @@protoc_insertion_point(field_set:CurrentTaskOutputRes.stateCode)
}

// string output = 2;
inline void CurrentTaskOutputRes::clear_output() {
  output_.ClearToEmpty();
}
inline const std::string& CurrentTaskOutputRes::output() const {
  // @@protoc_insertion_point(field_get:CurrentTaskOutputRes.output)
  return _internal_output();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CurrentTaskOutputRes::set_output(ArgT0&& arg0, ArgT... args) {
 
 output_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CurrentTaskOutputRes.output)
}
inline std::string* CurrentTaskOutputRes::mutable_output() {
  std::string* _s = _internal_mutable_output();
  // @@protoc_insertion_point(field_mutable:CurrentTaskOutputRes.output)
  return _s;
}
inline const std::string& CurrentTaskOutputRes::_internal_output() const {
  return output_.Get();
}
inline void CurrentTaskOutputRes::_internal_set_output(const std::string& value) {
  
  output_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CurrentTaskOutputRes::_internal_mutable_output() {
  
  return output_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CurrentTaskOutputRes::release_output() {
  // @@protoc_insertion_point(field_release:CurrentTaskOutputRes.output)
  return output_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CurrentTaskOutputRes::set_allocated_output(std::string* output) {
  if (output != nullptr) {
    
  } else {
    
  }
  output_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), output,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CurrentTaskOutputRes.output)
}

// -------------------------------------------------------------------

// TaskExitStateRes

// .StateCode stateCode = 1;
inline void TaskExitStateRes::clear_statecode() {
  statecode_ = 0;
}
inline ::StateCode TaskExitStateRes::_internal_statecode() const {
  return static_cast< ::StateCode >(statecode_);
}
inline ::StateCode TaskExitStateRes::statecode() const {
  // @@protoc_insertion_point(field_get:TaskExitStateRes.stateCode)
  return _internal_statecode();
}
inline void TaskExitStateRes::_internal_set_statecode(::StateCode value) {
  
  statecode_ = value;
}
inline void TaskExitStateRes::set_statecode(::StateCode value) {
  _internal_set_statecode(value);
  // @@protoc_insertion_point(field_set:TaskExitStateRes.stateCode)
}

// string workDir = 2;
inline void TaskExitStateRes::clear_workdir() {
  workdir_.ClearToEmpty();
}
inline const std::string& TaskExitStateRes::workdir() const {
  // @@protoc_insertion_point(field_get:TaskExitStateRes.workDir)
  return _internal_workdir();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskExitStateRes::set_workdir(ArgT0&& arg0, ArgT... args) {
 
 workdir_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TaskExitStateRes.workDir)
}
inline std::string* TaskExitStateRes::mutable_workdir() {
  std::string* _s = _internal_mutable_workdir();
  // @@protoc_insertion_point(field_mutable:TaskExitStateRes.workDir)
  return _s;
}
inline const std::string& TaskExitStateRes::_internal_workdir() const {
  return workdir_.Get();
}
inline void TaskExitStateRes::_internal_set_workdir(const std::string& value) {
  
  workdir_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskExitStateRes::_internal_mutable_workdir() {
  
  return workdir_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskExitStateRes::release_workdir() {
  // @@protoc_insertion_point(field_release:TaskExitStateRes.workDir)
  return workdir_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskExitStateRes::set_allocated_workdir(std::string* workdir) {
  if (workdir != nullptr) {
    
  } else {
    
  }
  workdir_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), workdir,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:TaskExitStateRes.workDir)
}

// string programName = 3;
inline void TaskExitStateRes::clear_programname() {
  programname_.ClearToEmpty();
}
inline const std::string& TaskExitStateRes::programname() const {
  // @@protoc_insertion_point(field_get:TaskExitStateRes.programName)
  return _internal_programname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskExitStateRes::set_programname(ArgT0&& arg0, ArgT... args) {
 
 programname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TaskExitStateRes.programName)
}
inline std::string* TaskExitStateRes::mutable_programname() {
  std::string* _s = _internal_mutable_programname();
  // @@protoc_insertion_point(field_mutable:TaskExitStateRes.programName)
  return _s;
}
inline const std::string& TaskExitStateRes::_internal_programname() const {
  return programname_.Get();
}
inline void TaskExitStateRes::_internal_set_programname(const std::string& value) {
  
  programname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskExitStateRes::_internal_mutable_programname() {
  
  return programname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskExitStateRes::release_programname() {
  // @@protoc_insertion_point(field_release:TaskExitStateRes.programName)
  return programname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskExitStateRes::set_allocated_programname(std::string* programname) {
  if (programname != nullptr) {
    
  } else {
    
  }
  programname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), programname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:TaskExitStateRes.programName)
}

// repeated string args = 4;
inline int TaskExitStateRes::_internal_args_size() const {
  return args_.size();
}
inline int TaskExitStateRes::args_size() const {
  return _internal_args_size();
}
inline void TaskExitStateRes::clear_args() {
  args_.Clear();
}
inline std::string* TaskExitStateRes::add_args() {
  std::string* _s = _internal_add_args();
  // @@protoc_insertion_point(field_add_mutable:TaskExitStateRes.args)
  return _s;
}
inline const std::string& TaskExitStateRes::_internal_args(int index) const {
  return args_.Get(index);
}
inline const std::string& TaskExitStateRes::args(int index) const {
  // @@protoc_insertion_point(field_get:TaskExitStateRes.args)
  return _internal_args(index);
}
inline std::string* TaskExitStateRes::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:TaskExitStateRes.args)
  return args_.Mutable(index);
}
inline void TaskExitStateRes::set_args(int index, const std::string& value) {
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:TaskExitStateRes.args)
}
inline void TaskExitStateRes::set_args(int index, std::string&& value) {
  args_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:TaskExitStateRes.args)
}
inline void TaskExitStateRes::set_args(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TaskExitStateRes.args)
}
inline void TaskExitStateRes::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TaskExitStateRes.args)
}
inline std::string* TaskExitStateRes::_internal_add_args() {
  return args_.Add();
}
inline void TaskExitStateRes::add_args(const std::string& value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TaskExitStateRes.args)
}
inline void TaskExitStateRes::add_args(std::string&& value) {
  args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TaskExitStateRes.args)
}
inline void TaskExitStateRes::add_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TaskExitStateRes.args)
}
inline void TaskExitStateRes::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TaskExitStateRes.args)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TaskExitStateRes::args() const {
  // @@protoc_insertion_point(field_list:TaskExitStateRes.args)
  return args_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TaskExitStateRes::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:TaskExitStateRes.args)
  return &args_;
}

// int32 exitCode = 5;
inline void TaskExitStateRes::clear_exitcode() {
  exitcode_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaskExitStateRes::_internal_exitcode() const {
  return exitcode_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TaskExitStateRes::exitcode() const {
  // @@protoc_insertion_point(field_get:TaskExitStateRes.exitCode)
  return _internal_exitcode();
}
inline void TaskExitStateRes::_internal_set_exitcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  exitcode_ = value;
}
inline void TaskExitStateRes::set_exitcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_exitcode(value);
  // @@protoc_insertion_point(field_set:TaskExitStateRes.exitCode)
}

// -------------------------------------------------------------------

// File

// bytes content = 1;
inline void File::clear_content() {
  content_.ClearToEmpty();
}
inline const std::string& File::content() const {
  // @@protoc_insertion_point(field_get:File.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void File::set_content(ArgT0&& arg0, ArgT... args) {
 
 content_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:File.content)
}
inline std::string* File::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:File.content)
  return _s;
}
inline const std::string& File::_internal_content() const {
  return content_.Get();
}
inline void File::_internal_set_content(const std::string& value) {
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* File::_internal_mutable_content() {
  
  return content_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* File::release_content() {
  // @@protoc_insertion_point(field_release:File.content)
  return content_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void File::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:File.content)
}

// -------------------------------------------------------------------

// FileRes

// .StateCode stateCode = 1;
inline void FileRes::clear_statecode() {
  statecode_ = 0;
}
inline ::StateCode FileRes::_internal_statecode() const {
  return static_cast< ::StateCode >(statecode_);
}
inline ::StateCode FileRes::statecode() const {
  // @@protoc_insertion_point(field_get:FileRes.stateCode)
  return _internal_statecode();
}
inline void FileRes::_internal_set_statecode(::StateCode value) {
  
  statecode_ = value;
}
inline void FileRes::set_statecode(::StateCode value) {
  _internal_set_statecode(value);
  // @@protoc_insertion_point(field_set:FileRes.stateCode)
}

// string path = 2;
inline void FileRes::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& FileRes::path() const {
  // @@protoc_insertion_point(field_get:FileRes.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileRes::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FileRes.path)
}
inline std::string* FileRes::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:FileRes.path)
  return _s;
}
inline const std::string& FileRes::_internal_path() const {
  return path_.Get();
}
inline void FileRes::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileRes::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileRes::release_path() {
  // @@protoc_insertion_point(field_release:FileRes.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FileRes::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:FileRes.path)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::StateCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::StateCode>() {
  return ::StateCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_stq_2eproto
